% === BEGIN TEMPLATE ===

% !!!THE ORDER MATTERS, DON'T CHANGE THE ORDER OF PACKAGES!!!

\documentclass[14pt]{extreport}

% misc
\usepackage[italian]{babel} % set the language to italian
\usepackage{indentfirst} % spacing at the beginning of every paragraph
\usepackage[margin = 1.0in]{geometry} % size of the margins

% tools
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage[capitalize,nameinlink,italian]{cleveref}
\usepackage{xcolor}
\hypersetup{colorlinks,linkcolor={red!50!black},citecolor={blue!50!black},urlcolor={blue!80!black}} % change the colors of cleveref
\usepackage{float}
\usepackage[linesnumbered,ruled,italiano]{algorithm2e}
\numberwithin{algocf}{subsection} % algorithms numbered within subsections
\SetKwInOut{Input}{Input} % keyword for algorithms
\SetKwInOut{Output}{Output} % keyword for algorithms
\DontPrintSemicolon % don't print semicolon at the end of every line in algorithms
\SetArgSty{textnormal} % don't use italics font inside conditions
\SetKwProg{Fn}{Function}{}{end} % keyword for function definition in algorithms

% theorems
\newtheorem{theorem}{Teorema}[subsection]
\newtheorem{corollary}{Corollario}[subsection]
\newtheorem{lemma}{Lemma}[subsection]
\theoremstyle{definition}
\newtheorem{definition}{Definizione}[subsection]
\theoremstyle{definition}
\newtheorem{remark}{Osservazione}[subsection]
\newtheorem{example}{Esempio}[subsection]

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm}

    \textbf{\huge Progettazione di Algoritmi}

    \vspace{1.5cm}

    \textit{\Large Alessio Bandiera}

    \vfill
        
    \large Informatica, La Sapienza
\end{titlepage}

\tableofcontents

\pagebreak

% === END TEMPLATE ===

\chapter{Grafi}

\section{Grafi}

\subsection{Definizioni}

\begin{definition}[Grafo]
    Un grafo è una struttura matematica descritta da vertici, collegati da archi. Un grafo viene descritto formalmente come $G=(V, E)$, dove i $v \in V$ sono i \textit{vertici} del grafo, mentre gli $e \in E$ sono gli \textit{archi} (dall'inglese \textit{edges}). In particolare, $V(G)$ è l'insieme dei vertici di $G$, comunemente indicato con $n$, mentre $E(G)$ è l'insieme degli archi di $G$, comunemente indicato con $m$. Presi due vertici $v_1,v_2 \in V(G)$, allora $(v_1, v_2) \in E(G)$ è l'arco che li collega.
\end{definition}

\begin{remark}
    $E(G) \subseteq V^2$.
\end{remark}

\begin{definition}[Vertici adiacenti]
    $v_1, v_2 \in V(G)$ sono detti \textit{adiacenti} se $(v_1, v_2) \in E(G)$; in tal caso, si usa la notazione $v_1 \sim v_2$.
\end{definition}

\begin{definition}[Grafo indiretto]
    Un grafo è detto \textit{indiretto} se gli archi non hanno direzione, o equivalentemente $$\forall v_1, v_2 \in V(G) \quad (v_1, v_2) = (v_2, v_1) \in E(G)$$
\end{definition}

\begin{example}[Grafo indiretto]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (4) [below left of=5] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (1)
                (6) edge (3)
                (6) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si hanno $$V(G) = \{1, 2, 3, 4, 5, 6\}$$ $$E(G) = \{(1, 2), (1, 4), (1, 5) (2, 3), (2, 4), (3, 4), (3, 6), (5, 6)\}$$
\end{example}

\begin{definition}[Grafo diretto]
    Un grafo è detto \textit{diretto} se gli archi hanno direzione, o equivalentemente $$\forall v_1, v_2 \in V(G) \quad (v_1, v_2) \neq (v_2, v_1) \in E(G)$$
\end{definition}

\begin{example}[Grafo diretto]
    Ad esempio, si consideri questo grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (4) [below left of=5] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (1)
                (6) edge (3)
                (6) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    in esso, si hanno $$V(G) = \{1, 2, 3, 4, 5, 6\}$$ $$E(G) = \{(1, 2), (2, 3), (2, 4), (3, 4), (4, 1), (5, 1), (6, 3), (6, 5)\}$$
\end{example}

\begin{definition}[Grado]
    Il \textit{grado} di un vertice $v \in V(G)$ è il numero di archi incidenti su $v$, indicato con $\deg(v)$.
\end{definition}

\begin{theorem}[Somma dei gradi]
\label{Somma dei gradi}
    Dato un grafo $G$, la somma dei gradi dei vertici è pari a $2 |E(G)|$.
\end{theorem}

\begin{proof}
    Sia $G$ un grafo. Allora, ogni arco $e \in E(G)$ collega due vertici; allora necessariamente $\displaystyle \sum_{v \in V(G)}{\deg(v)} = 2 |E(G)|$.
\end{proof}

\begin{definition}[Cappio]
    Un arco con estremi coincidenti è detto \textit{cappio}.
\end{definition}

\begin{example}[Grafo con cappio]
    Un esempio di grafo con cappio è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (1)
                (3) edge [loop below] (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto con cappio in 3.}
    \end{figure}
\end{example}

\begin{definition}[Grafo semplice]
    Un grafo è detto \textit{semplice} se non contiene cappi, né lati multipli, ovvero più archi per due vertici.
\end{definition}

\subsection{Visite}

\begin{definition}[Passeggiata]
    Una \textit{passeggiata} è una sequenza di vertici ed archi, della forma $v_0, e_1, v_1, e_2, \ldots , e_{n - 1}, v_{n - 1}, e_n, v_n$, dove $e_i=(v_{i - 1}, v_i)$. È la visita di un grafo più generale, ed è possibile ripercorrere ogni arco ed ogni vertice.
\end{definition}

\begin{remark}
    La lunghezza massima di una passeggiata su un grafo è infinita.
\end{remark}

\begin{definition}[Passeggiata chiusa]
    Una passeggiata si dice \textit{chiusa} se è della forma $v_0, e_1, v_1, e_2, \ldots , e_{n - 1}, v_{n - 1}, e_n, v_0$, dunque il primo e l'ultimo vertice coincidono. 
\end{definition}

\begin{definition}[Traccia]
    Una \textit{traccia} è una passeggiata aperta, in cui non è possibile ripercorrere gli archi, ma è possibile ripercorrere i vertici.
\end{definition}

\begin{example}[Traccia di un grafo]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=4] {6};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (4) edge (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si ha la traccia $$\{5, (5,4), 4, (4,3), 3, (3, 2), 2, (2,4), 4, (4, 6), 6\}$$
\end{example}

\begin{definition}[Circuito]
    Un \textit{circuito} è una traccia chiusa.
\end{definition}

\begin{definition}[Cammino]
    Un \textit{cammino} è una traccia aperta, in cui non è possibile ripercurrere i vertici.
\end{definition}

\begin{remark}
    In una passeggiata in cui non si ripercorrono i vertici, non è possibile ripercorrere gli archi
\end{remark}

\begin{definition}[Ciclo]
    Un \textit{ciclo} è un cammino chiuso.
\end{definition}

\begin{example}[Cicli di un grafo]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si hanno tre cicli: $$\{2, (2, 4), 4, (4,3), 3, (3, 2), 2\}$$ $$\{2, (2, 4), 4, (4, 1), 1, (1, 2), 2\}$$ $$\{1, (1, 2), 2, (2, 3), 3, (3, 4), 4, (4, 1), 1\}$$
\end{example}

\begin{definition}[Grafo connesso]
    Un grafo è detto \textit{connesso} se per ogni $v_1, v_2 \in V(G)$ esiste una passeggiata che li collega.
\end{definition}

\begin{example}[Grafo non connesso]
    Ad esempio, si consideri questo grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [right of=4] {5};
            \node[main node] (6) [above right of=5] {6};
            \node[main node] (7) [below right of=5] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (6)
                (6) edge (7)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo non connesso.}
    \end{figure}

    Poiché non esiste una passeggiata che possa collegare $4$ e $5$, il grafo non è connesso.
\end{example}

\begin{definition}[Grafo fortemente connesso]
    Un grafo diretto è detto \textit{fortemente connesso} se per ogni $v_1, v_2 \in V(G)$ esistono due cammini diretti, che li collegano in entrambe i versi.
\end{definition}

\begin{example}[Grafo fortemente connesso]
    Un esempio di grafo fortemente connesso è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo fortemente connesso.}
    \end{figure}
\end{example}

\begin{definition}[Passeggiata euleriana]
    Una passeggiata si dice \textit{euleriana} se attraversa ogni arco del grafo, senza ripercorrerne nessuno.
\end{definition}

\begin{remark}
    Una passeggiata euleriana è una traccia passante per ogni arco del grafo.
\end{remark}

\begin{example}[Passeggiata euleriana]
    Ad esempio, si consideri il seguente grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, l'unica passeggiata euleriana è $$\{1, (1,2), 2, (2,3), 3\}$$
\end{example}

\begin{theorem}
    Dato un grafo $G$, esiste un circuito euleriano su $G$ se e solo se $G$ è connesso, e per ogni $v$, $\deg(v)$ è pari.
\end{theorem}

\begin{proof}
    \textit{Prima implicazione.} Sia $G$ un grafo avente un circuito euleriano; per assurdo, sia $v \in V(G) \mid \deg(v)$ non sia pari. Allora, percorrendo $G$ secondo il circuito euleriano, giungendo a $v$ non si potrebbe più lasciare tale vertice senza riattraversare uno degli archi gia visitati. Inoltre, se $G$ non fosse connesso, il circuito non potrebbe essere euleriano poiché non potrebbe attraversare tutti gli archi di $G$. \textit{Seconda implicazione.} TODO
\end{proof}

\begin{definition}[Passeggiata hamiltoniana]
    Una passeggiata si dice \textit{hamiltoniana} se TODO
\end{definition}

\section{Rappresentazione}

\subsection{Matrici di adiacenza}

\begin{definition}[Matrice di adiacenza]
    Sia $G = (V, E)$ un grafo; allora, è possibile rappresentare $G$ attraverso una matrice $M_G \in \textrm{Mat}_{n \times n}(\{0, 1\})$, dove $$\forall m_{i, j} \in M_G \quad m_{i, j} = \left \{ \begin{array}{ll} 1 & i \sim j\\ 0 & i \nsim j \end{array} \right.$$
\end{definition}

\begin{remark}[Spazio di una matrice]
    Lo spazio utilizzato da una matrice di adiacenza è pari a $O(n^2)$, poiché è necessario rappresentare l'adiacenza di ogni vertice con ogni altro.
\end{remark}

\begin{remark}[Aggiornamento di una matrice]
    Per ogni grafo $G$, si ha che $M_G$ è simmetrica; di conseguenza, il costo per aggiornare una matrice di adiacenza è $2 O(1)= O(2) = O(1)$, poiché per $v_i, v_j \in V(G)$ non coincidenti, sarà necessario aggiornare $M_G[i, j]$ e $M_G[j, i]$.
\end{remark}

\begin{remark}[Controllo di adiacenza]
    Per controllare che $v_i, v_j \in V(G)$ non coincidenti siano adiacenti, sarà sufficiente controllare $M_G[i, j] = M_G[j, i]$, e dunque il costo di un controllo è $O(1)$.
\end{remark}

\subsection{Liste di adiacenza}

\begin{definition}[Liste di adiacenza]
    Sia $G = (V, E)$ un grafo; allora, è possibile rappresentare $G$ attraverso liste di adiacenza, salvando dunque una lista per ogni vertice, contenente i vertici ad esso adiacenti; in simboli $$\forall v \in V(G) \quad v:[\hat{v} \in V(G) - \{v\} \mid \hat{v} \sim v]$$
\end{definition}

\begin{remark}[Spazio delle liste]
    Dato un certo $v \in V(G)$, la lista di adiacenza corrispondente ha lunghezza$\deg(v)$; allora, il numero di elementi nelle liste di adiacenza, per il \cref{Somma dei gradi}, è pari a $\displaystyle O \left(\sum_{v \in V(G)}{\deg(v)}\right) = O\left( 2 |E(G)| \right)=O(2m) = O(m)$. Si noti inoltre che, per un grafo con pochi archi, nonostante si abbiano le liste poco riempite, è comunque necessario salvare i puntatori a tali liste, e dunque è necessario introdurre un $O(n)$ nel costo totale dello spazio, ottenendo allora $O(n) + O(m) = O(n + m)$.
\end{remark}

\begin{remark}[Controllo di adiacenza]
    Nel caso peggiore, il grafo rappresentato da liste di adiacenza sarà composto da una sola lista per un certo $v \in V(G)$, contenente ogni altro vertice del grafo $\hat{v} \in V(G) - \{v\}$, e la lunghezza della lista di adiacenza di $v$ sarà $n - 1$. Di conseguenza, il costo per controllare se due vertici sono adiacenti, utilizzando tale rappresentazione, è $O(n)$.
\end{remark}

\begin{example}[Rappresentazione di un grafo]
    Ad esempio, si consideri il seguente grafo $G$:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=4] {6};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (4) edge (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    allora, la sua corrispondente matrice di adiacenza è
    $$M_G = \left( \begin{array}{llllll}
        0 & 0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 1 & 0 & 0 \\
        0 & 1 & 0 & 1 & 0 & 0 \\
        1 & 1 & 1 & 0 & 1 & 1 \\
        0 & 0 & 0 & 1 & 0 & 1 \\
        0 & 0 & 0 & 1 & 1 & 0 \\
    \end{array} \right)$$

    mentre le corrispondenti liste di adiacenza sono $$\left \{ \begin{array}{l} 1: [4] \\ 2: [4, 3] \\ 3: [2, 4] \\ 4: [1, 3, 5, 6] \\ 5: [4, 6] \\ 6: [4, 5] \end{array} \right.$$
\end{example}

\section{Algoritmi}

\subsection{Trovare un ciclo}

\begin{algorithm}[H]
    \Input{$G$ grafo indiretto, tale che $\forall v \in V(G) \quad \deg(v) \ge 2$}
    \Output{Un ciclo di $G$}

    \SetKwFunction{findCycle}{findCycle}
    
    \Fn{\findCycle{$G$}}{
        $v \in V(G)$ \tcp*{un vertice qualsiasi di $G$}
        $\texttt{visited} := [v]$ \tcp*{conterrà i vertici visitati}
        $v' \in V(G) : v \sim v'$\\
        \While{$v' \notin \texttt{visited}$}{
            $\texttt{visited.add}(v')$\\
            $v' := v'' \in V(G) : \left \{ \begin{array}{l}v' \sim v'' \\ v'' \neq\texttt{visited}[\texttt{visited.length} - 2] \end{array} \right.$
        }
        \Return $\texttt{visited}[\texttt{visited.indexOf}(v') \texttt{:} \texttt{visited.length}]$
    }

    \caption{Dato un grafo indiretto $G$, con ogni vertice avente grado almeno pari a $2$, l'algoritmo restiuisce un ciclo di $G$.}
\end{algorithm}

\begin{proof}
    L'algoritmo inizia scegliendo un qualsiasi vertice di $G$, denotato alla riga $2$ con $v$; successivamente, alla riga $3$ viene inizializzato un array \texttt{visited} che contterà tutti i vertici visitati attraverso l'algoritmo; inotre, alla riga $4$ viene scelto un altro vertice $v'$, che sia adiacente al $v$ di partenza.

    All'interno del ciclo \texttt{while}, alla riga $6$ l'algoritmo salva $v'$ all'interno dell'array di vertici visitati, mentre alla riga $7$ viene rimpiazzato $v'$, scegliendo un nuovo vertice, adiacente a $v'$, che sia diverso dal penultimo vertice inserito all'interno di \texttt{visited}. Il motivo per cui quest'ultimo controllo è necessario, è che il penultimo vertice inserito sarà il vertice dal quale $v'$ proveniva, di conseguenza si rischierebbe di ripercorrere uno stesso vertice più di una volta, e dunque non si formerebbe un ciclo. Si noti che è necessaria l'ipotesi per cui $G$ abbia ogni vertice di grado almeno pari a $2$, altrimenti non sarebbe possibile trovare un vertice differente dal penultimo di \texttt{visited}. Il ciclo termina nel momento in cui viene scelto un $v'$ già presente all'interno di \texttt{visited}, in quanto, poiché non è possibile ripercorrere i propri passi, l'unica possibilità in cui si è giunti ad un vertice già visitato è se si è concluso un ciclo.
    
    L'algoritmo termina restituendo uno slice dell'array, partendo dal primo indice di $v'$ disponibile (si noti che alla fine dell'algoritmo anche l'ultimo elemento di \texttt{visited} sarà $v'$), fino alla fine.
\end{proof}

\begin{remark}
    Si noti che \texttt{visited} contiene tutti i nodi visitati, dunque restituire interamente l'array potrebbe non fornire un ciclo, come nel seguente grafo
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo contenente un ciclo.}
    \end{figure}

    in cui, ad esempio partendo da $v= 4$, l'unico ciclo è $$\{4, (4, 3), 3, (3, 2), 2, (2, 4), 4\}$$ nonostante al termine dell'algoritmo si avrebbe $\texttt{visited}=[1, 4, 3, 2, 4]$, che non costituisce un ciclo.

\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Il costo di questo algoritmo dipende dalla struttura dati utilizzata per rappresentare il grafo in input: nel caso in cui $G$ è rappresentato attraverso una matrice di adiacenza, il costo del ciclo \texttt{while} è pari a $O(n)$, poiché la riga $7$ richiede di trovare un $v'' \in V(G) : v' \sim v''$, il ché potrebbe portare a dover scorrere tutta la riga/colonna di $v''$, dunque nel caso peggiore $O(n)$; differentemente, rappresentando $G$ attraverso liste di adiacenza, basta scegliere il primo vertice contenuto nella lista di $v''$, e se questo dovesse coincidere con il penultimo elemento di \texttt{visited}, sarà sufficiente scegliere il secondo elemento della lista (sicuramente presente per come $G$ è scelto in ipotesi), dunque si ha $O(2) = O(1)$.

    Infine, si noti che il ciclo \texttt{while} ha costo $O(n)$, poiché nel caso peggiore si ha un ciclo che percorre tutto il grafo.

    Allora, tramite matrice l'algoritmo ha costo $O(n) \cdot O(n) = O(n^2)$, mentre tramite liste si ha $O(1) \cdot O(n) = O(n)$.
\end{remark}

\subsection{DFS (Depth-First Search)}

\begin{algorithm}[H]
    \Input{$G$ grafo indiretto}
    \Output{$v$ un vertice di $G$}

    \SetKwFunction{DFSFirst}{DFS$_1$}
    
    \Fn{\DFSFirst{$G$, v}}{
        $\texttt{visited}:=[0] * n$ \tcp*{array di $n$ zeri}
        $\texttt{visited}[v] = 1$\\
        $\texttt{Stack S}=[v]$\\
        \While{$!\texttt{S.isEmpty()}$}{
            $v_{top}=\texttt{S.top()}$\\
            \eIf{$\exists z \in V(G) : \left \{ \begin{array}{l}z \sim v_{top} \\ \texttt{visited}[z]=0 \end{array} \right.$}
                {
                    $\texttt{S.push(z)}$\\
                    $\texttt{visited}[z] = 1$
                }
                {
                    $\texttt{S.pop()}$\\
                }
        }
        \Return \texttt{visited}
    }

    \caption{Prima versione del DFS; dato un grafo indiretto $G$, e un vertice $v$ di esso, l'algoritmo restituisce tutti i vertici raggiungibili attraverso un cammino, partendo da $v$.}
\end{algorithm}

\begin{proof}
    TODO
\end{proof}

\begin{remark}[Costo dell'algoritmo]
    TODO
\end{remark}

\begin{algorithm}[H]
    \Input{$G$ grafo indiretto}
    \Output{$v$ un vertice di $G$}

    \SetKwFunction{DFSSecond}{DFS$_2$}
    
    \Fn{\DFSSecond{$G$, v}}{
        TODO
        % $\texttt{visited}:=[0] * n$ \tcp*{array di $n$ zeri}
        % $\texttt{visited}[v] = 1$\\
        % $\texttt{Stack S}=[v]$\\
        % \While{$!\texttt{S.isEmpty()}$}{
        %     $v_{top}=\texttt{S.top()}$\\
        %     \eIf{$\exists z \in V(G) : \left \{ \begin{array}{l}z \sim v_{top} \\ \texttt{visited}[z]=0 \end{array} \right.$}
        %         {
        %             $\texttt{S.push(z)}$\\
        %             $\texttt{visited}[z] = 1$
        %         }
        %         {
        %             $\texttt{S.pop()}$\\
        %         }
        % }
        % \Return \texttt{visited}
    }

    \caption{Seconda versione del DFS; dato un grafo indiretto $G$, e un vertice $v$ di esso, l'algoritmo restituisce tutti i vertici raggiungibili attraverso un cammino, partendo da $v$.}
\end{algorithm}

\end{document}
