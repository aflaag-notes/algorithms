% === BEGIN TEMPLATE ===

% !!!THE ORDER MATTERS, DON'T CHANGE THE ORDER OF PACKAGES!!!

\documentclass[14pt]{extreport}

% misc
\usepackage[italian]{babel} % set the language to italian
\usepackage{indentfirst} % spacing at the beginning of every paragraph
\usepackage[margin = 1.0in]{geometry} % size of the margins

% tools
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage[capitalize,nameinlink,italian]{cleveref}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{stmaryrd}
\let\stmaryrdLightning\lightning
\hypersetup{colorlinks,linkcolor={red!50!black},citecolor={blue!50!black},urlcolor={blue!80!black}} % change the colors of cleveref
\usepackage{float}
\usepackage[Algoritmo]{algorithm}
\usepackage{algpseudocode}
\counterwithin{algorithm}{subsection}
\newenvironment{nocaptionalg} % environment for algorithms without caption
{
    \par\addvspace{\topsep}
    \centering
    \begin{minipage}{\linewidth}
    \hrule\kern2pt
}
{
    \par\kern2pt\hrule
    \end{minipage}
    \par\addvspace{\topsep}
}

% theorems
\newtheorem{theorem}{Teorema}[subsection]
\newtheorem{corollary}{Corollario}[subsection]
\newtheorem{lemma}{Lemma}[subsection]
\theoremstyle{definition}
\newtheorem{definition}{Definizione}[subsection]
\theoremstyle{definition}
\newtheorem{remark}{Osservazione}[subsection]
\newtheorem{example}{Esempio}[subsection]

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm}

    \textbf{\huge Progettazione di Algoritmi}

    \vspace{1.5cm}

    \textit{\Large Alessio Bandiera}

    \vfill
        
    \large Informatica, La Sapienza
\end{titlepage}

\tableofcontents

\pagebreak

% === END TEMPLATE ===

\chapter{Teoria dei Grafi}

\section{Grafi}

\subsection{Definizioni}

\begin{definition}[Grafo]
    Un grafo è una struttura matematica descritta da vertici, collegati da archi. Un grafo viene descritto formalmente come $G=(V, E)$, dove i $v \in V$ sono i \textit{vertici} o \textit{nodi} del grafo, mentre gli $e \in E$ sono gli \textit{archi} (dall'inglese \textit{edges}). In particolare, $V(G)$ è l'insieme dei vertici di $G$, comunemente indicato con $n$, mentre $E(G)$ è l'insieme degli archi di $G$, comunemente indicato con $m$. Presi due vertici $v_1,v_2 \in V(G)$, allora $(v_1, v_2) \in E(G)$ è l'arco che li collega.
\end{definition}

\begin{remark}
    $E(G) \subseteq V^2$.
\end{remark}

\begin{definition}[Vertici adiacenti]
    $v_1, v_2 \in V(G)$ sono detti \textit{adiacenti} se $(v_1, v_2) \in E(G)$; in tal caso, si usa la notazione $v_1 \sim v_2$.
\end{definition}

\begin{definition}[Sottografo]
    Dato un grafo $G = (V, E)$, un sottografo $G'$ di $G$ è un grafo della forma $G' = (V', E'): \left \{ \begin{array}{l} V' \subseteq V \\ E' \subseteq E \end{array} \right.$. Si noti che $G$ è sottografo di sè stesso.
\end{definition}

\begin{definition}[Grafo indiretto]
    Un grafo è detto \textit{indiretto} se gli archi non hanno direzione, o equivalentemente $$\forall v_1, v_2 \in V(G) \quad (v_1, v_2) = (v_2, v_1) \in E(G)$$
\end{definition}

\begin{example}[Grafo indiretto]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (4) [below left of=5] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (1)
                (6) edge (3)
                (6) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si hanno $$V(G) = \{1, 2, 3, 4, 5, 6\}$$ $$E(G) = \{(1, 2), (1, 4), (1, 5) (2, 3), (2, 4), (3, 4), (3, 6), (5, 6)\}$$
\end{example}

\begin{definition}[Grafo diretto]
    Un grafo è detto \textit{diretto} se gli archi hanno direzione, o equivalentemente $$\forall v_1, v_2 \in V(G) \quad (v_1, v_2) \neq (v_2, v_1) \in E(G)$$
\end{definition}

\begin{example}[Grafo diretto]
    Ad esempio, si consideri questo grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (4) [below left of=5] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (1)
                (6) edge (3)
                (6) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    in esso, si hanno $$V(G) = \{1, 2, 3, 4, 5, 6\}$$ $$E(G) = \{(1, 2), (2, 3), (2, 4), (3, 4), (4, 1), (5, 1), (6, 3), (6, 5)\}$$
\end{example}

\begin{definition}[Grado]
    Il \textit{grado} di un vertice $v \in V(G)$ è il numero di archi incidenti su $v$, indicato con $\deg(v)$.
\end{definition}

\begin{lemma}[Somma dei gradi]
    \label{Somma dei gradi}
    Dato un grafo $G$, la somma dei gradi dei vertici è pari a $2 |E(G)|$.
\end{lemma}

\begin{proof}
    Sia $G$ un grafo. Allora, ogni arco $e \in E(G)$ collega due vertici; allora necessariamente $\displaystyle \sum_{v \in V(G)}{\deg(v)} = 2 |E(G)|$.
\end{proof}

\begin{definition}[Cappio]
    Un arco con estremi coincidenti è detto \textit{cappio}.
\end{definition}

\begin{example}[Grafo con cappio]
    Un esempio di grafo con cappio è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (1)
                (3) edge [loop below] (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto con cappio in 3.}
    \end{figure}
\end{example}

\begin{definition}[Grafo semplice]
    Un grafo è detto \textit{semplice} se non contiene cappi, né lati multipli, ovvero più archi per due vertici.
\end{definition}

\subsection{Visite}

\begin{definition}[Passeggiata]
    Una \textit{passeggiata} è una sequenza di vertici ed archi, della forma $\{v_0, e_1, v_1, e_2, \ldots , e_{k - 1}, v_{k - 1}, e_k, v_k\}$, dove $e_i=(v_{i - 1}, v_i)$. È la visita di un grafo più generale, ed è possibile ripercorrere ogni arco ed ogni vertice.
\end{definition}

\begin{remark}
    La lunghezza massima di una passeggiata su un grafo è infinita.
\end{remark}

\begin{definition}[Passeggiata chiusa]
    Una passeggiata si dice \textit{chiusa} se è della forma $\{v_0, e_1, v_1, e_2, \ldots , e_{k - 1}, v_{k - 1}, e_k, v_0\}$, dunque il primo e l'ultimo vertice coincidono. 
\end{definition}

\begin{definition}[Traccia]
    Una \textit{traccia} è una passeggiata aperta, in cui non è possibile ripercorrere gli archi, ma è possibile ripercorrere i vertici.
\end{definition}

\begin{example}[Traccia di un grafo]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=4] {6};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (4) edge (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si ha la traccia $$\{5, (5,4), 4, (4,3), 3, (3, 2), 2, (2,4), 4, (4, 6), 6\}$$
\end{example}

\begin{definition}[Circuito]
    Un \textit{circuito} è una traccia chiusa.
\end{definition}

\begin{definition}[Cammino]
    Un \textit{cammino} è una traccia aperta, in cui non è possibile ripercurrere i vertici. In simboli, $\forall v, v' \in V(G) \quad v \rightarrow v'$ indica che è possibile raggiungere $v'$ attraverso un cammino; inoltre, è possibile estendere tale sintassi anche agli archi.
\end{definition}

\begin{remark}
    In una passeggiata in cui non si ripercorrono i vertici, non è possibile ripercorrere gli archi
\end{remark}

\begin{definition}[Ciclo]
    Un \textit{ciclo} è un cammino chiuso.
\end{definition}

\begin{example}[Cicli di un grafo]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si hanno tre cicli: $$\{2, (2, 4), 4, (4,3), 3, (3, 2), 2\}$$ $$\{2, (2, 4), 4, (4, 1), 1, (1, 2), 2\}$$ $$\{1, (1, 2), 2, (2, 3), 3, (3, 4), 4, (4, 1), 1\}$$
\end{example}

\begin{definition}[Ordinamento topologico]
    I vertici di un grafo diretto si definiscono \textit{ordinati topologicamente}, se disposti in modo tale che ogni vertice viene prima di tutti i vertici collegati ai suoi archi uscenti.
\end{definition}

\begin{example}[Ordinamento topologico]
    Ad esempio, nel seguente grafo sono presenti vari ordinamenti topologici:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=5] {6};
            \node[main node] (7) [below left of=6] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (4)
                (2) edge (1)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (5)
                (4) edge (7)
                (7) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto con ordinamenti topologici.}
    \end{figure}

    ad esempio, uno di questi è $\{2, 3, 1, 4, 5, 7, 6\}$.
\end{example}

\begin{theorem}[Ordinamento topologico]
    \label{Ordinamento topologico}
    Un grafo diretto $G$ ha un ordinamento topologico se e solo se è aciclico.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Per assurdo, sia $G$ un grafo diretto ciclico, avente dunque almeno un ciclo, con un ordinamento topologico, e siano $\{v_0, \ldots , v_{k - 1}, v_0\}$ i vertici che costituiscono uno dei cicli di $G$; allora, si ha che $v_0 \rightarrow v_1 \rightarrow \ldots \rightarrow v_{k - 1} \rightarrow v_0$, dunque all'interno dell'ordinamento topologico $v_0$ dovrebbe essere posto contemporaneamente prima e dopo $v_1, \ldots, v_{k - 1} \ \lightning$.
        \item[] \textit{Seconda implicazione.} Sia $G$ un grafo aciclico; allora per definizione, all'interno di esso non esistono cicli, ed è dunque possibile enumerare in sequenza ogni vertice $G$, senza creare dipendenze circloari, per poter trovare un ordinamento topologico del grafo.
    \end{itemize}
\end{proof}

\begin{corollary}[Vertici particolari]
    In un grafo diretto aciclico, esiste almeno un vertice senza archi entranti, ed almeno un vertice senza archi uscenti.
\end{corollary}

\begin{proof}
    Per il teorema \cref{Ordinamento topologico}, è sufficiente considerare un ordinamento topologico del grafo, dove in esso il primo vertice non ha archi entranti, mentre l'ultimo non ha archi uscenti.
\end{proof}

\begin{definition}[Pozzo universale]
    Sia $G$ un grafo diretto; $v \in V(G)$ è detto \textit{pozzo universale} se ha $n - 1$ archi entranti, e nessun arco uscente.
\end{definition}

\begin{example}[Pozzo universale]
    Ad esempio, il seguente grafo diretto presenta un pozzo universale in $3$:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [above right of=3] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (4) edge (3)
                (4) edge (1)
                (1) edge (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo con pozzo universale in $3$.}
    \end{figure}
\end{example}

\begin{theorem}[Unicità del pozzo universale]
    Sia $G$ un grafo diretto, e $p \in V(G)$ un suo pozzo universale; allora $p$ è unico in $G$.
\end{theorem}

\begin{proof}
    Per assurdo, sia $p' \in V(G)$ un secondo pozzo universale in $G$; allora, per definizione, sia $p$ che $p'$ avrebbero $n - 1$ archi entranti, e nessun arco uscente, ma questo non è possibile poiché l'unico modo per avere entrambe le condizioni verificate sarebbe attraverso un arco bidirezionale tra $p$ e $p' \ \lightning$.
\end{proof}

\begin{definition}[Arborescenza]
    Sia $G$ un grafo diretto, e $v$ un suo vertice; l'insieme degli archi raggiungibili da $v$ formano l'\textit{arborescenza di $v$}, e $v$ prende il nome di \textit{radice}. In simboli $$A_v := \{(v', v'') \in E(G) : v \rightarrow (v', v'')\} \subseteq E(G)$$ è l'arborescenza di $v$. Si noti che, spesso, il sottografo generato dall'arborescenza di $v$ viene identificato con l'arborescenza stessa.
\end{definition}

\begin{example}[Arborescenza]
    Si consideri il seguente grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (2) {2};
            \node[main node] (4) [below left of=2] {4};
            \node[main node] (1) [above left of=4] {1};
            \node[main node] (5) [below right of=2] {5};
            \node[main node] (3) [above right of=5] {3};
            \node[main node] (6) [below left of=4] {6};
            \node[main node] (7) [below right of=4] {7};
            \node[main node] (8) [below right of=5] {8};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (4)
                (2) edge (4)
                (2) edge (5)
                (3) edge (5)
                (3) edge (8)
                (4) edge (6)
                (4) edge (7)
                (5) edge (7)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    in esso, ad esempio il sottografo dell'arborescenza di $3$ è

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (3) {3};
            \node[main node] (5) [below left of=3] {5};
            \node[main node] (7) [below left of=5] {7};
            \node[main node] (8) [below right of=5] {8};

            \path[every node/.style={font=\sffamily\small}]
                (3) edge (5)
                (3) edge (8)
                (5) edge (7)
                ;
        \end{tikzpicture}
        \caption{Arborescenza di $3$.}
    \end{figure}
\end{example}

\begin{definition}[Grafo connesso]
    Un grafo è detto \textit{connesso} se per ogni $v_1, v_2 \in V(G)$ esiste un cammino che li collega. Nel caso dei grafi diretti, è sufficiente avere $v_1 \rightarrow v_2$, oppure $v_2 \rightarrow v_1$.
\end{definition}

\begin{example}[Grafo non connesso]
    Ad esempio, si consideri questo grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [right of=4] {5};
            \node[main node] (6) [above right of=5] {6};
            \node[main node] (7) [below right of=5] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (6)
                (6) edge (7)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo non connesso.}
    \end{figure}

    Poiché non esiste cammino che possa collegare $4$ e $5$, il grafo non è connesso.
\end{example}

\begin{definition}[Albero]
    Un grafo indiretto è detto \textit{albero} se è connesso ed aciclico.
\end{definition}

\begin{example}[Albero]
    Un esempio di albero è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [below right of=4] {5};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un albero.}
    \end{figure}
\end{example}

\begin{definition}[Grafo fortemente connesso]
    Un grafo diretto è detto \textit{fortemente connesso} se per ogni $v_1, v_2 \in V(G)$ esistono due cammini diretti, che li collegano in entrambe i versi; allora, è necessario avere $v_1 \rightarrow v_2$ e $v_2 \rightarrow v_1$. Si noti che ogni grafo indiretto connesso è anche fortemente connesso, poiché gli archi non hanno direzione.
\end{definition}

\begin{example}[Grafo fortemente connesso]
    Un esempio di grafo fortemente connesso è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo fortemente connesso.}
    \end{figure}
\end{example}

\begin{definition}[Ponte]
    Sia $G$ un grafo, e siano $u, v \in V(G)$ due suoi vertici; allora $(u, v)$ è detto \textit{ponte} se non è contenuto in nessun ciclo di $G$.
\end{definition}

\begin{example}[Ponte]
    Un esempio di grafo che presenta un ponte è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [right of=4] {5};
            \node[main node] (6) [above right of=5] {6};
            \node[main node] (7) [below right of=5] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (5) edge (6)
                (6) edge (7)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo con un ponte.}
    \end{figure}

    Infatti, $(4, 5)$ è un ponte poiché gli unici due cicli di $G$ sono $$\{1, (1, 2), 2, (2, 3), 3, (3, 4), 4, (4, 1), 1\}$$ $$\{5, (5, 6), 6, (6, 7), 7, (7, 5), 5\}$$
\end{example}

\begin{definition}[Passeggiata euleriana]
    Una passeggiata si dice \textit{euleriana} se attraversa ogni arco del grafo, senza ripercorrerne nessuno.
\end{definition}

\begin{remark}
    Una passeggiata euleriana è una traccia passante per ogni arco del grafo.
\end{remark}

\begin{example}[Passeggiata euleriana]
    Ad esempio, si consideri il seguente grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, l'unica passeggiata euleriana è $$\{1, (1,2), 2, (2,3), 3\}$$
\end{example}

\begin{theorem}
    Dato un grafo $G$, esiste un circuito euleriano su $G$ se e solo se $G$ è connesso, ed ogni grado dei vertici di $G$ è pari.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Sia $G$ un grafo avente un circuito euleriano; per assurdo, sia $v \in V(G) : \deg(v)$ non sia pari. Allora, percorrendo $G$ secondo il circuito euleriano, giungendo a $v$ non si potrebbe più lasciare tale vertice senza riattraversare uno degli archi gia visitati $\lightning$. Inoltre, se $G$ non fosse connesso, il circuito non potrebbe essere euleriano poiché non potrebbe attraversare tutti gli archi di $G$.
        \item[] \textit{Seconda implicazione.} Omessa.
    \end{itemize}
\end{proof}

\begin{definition}[Passeggiata hamiltoniana]
    Una passeggiata si dice \textit{hamiltoniana} se attraversa ogni nodo del grafo, senza ripercorrerne nessuno.
\end{definition}

\begin{remark}
    Una passeggiata hamiltoniana è un cammino.
\end{remark}

\section{Rappresentazione}

\subsection{Matrici di adiacenza}

\begin{definition}[Matrice di adiacenza]
    Sia $G = (V, E)$ un grafo; allora, è possibile rappresentare $G$ attraverso una matrice $M_G \in \textrm{Mat}_{n \times n}(\{0, 1\})$, dove $$\forall m_{i, j} \in M_G \quad m_{i, j} = \left \{ \begin{array}{ll} 1 & i \sim j\\ 0 & i \nsim j \end{array} \right.$$
\end{definition}

\begin{remark}[Spazio di una matrice]
    Lo spazio utilizzato da una matrice di adiacenza è pari a $O(n^2)$, poiché è necessario rappresentare l'adiacenza di ogni vertice con ogni altro.
\end{remark}

\begin{remark}[Aggiornamento di una matrice]
    Per ogni grafo $G$ indiretto, si ha che $M_G$ è simmetrica; di conseguenza, il costo per aggiornare la corrispondente matrice di adiacenza è $2 O(1)= O(2) = O(1)$, poiché per $v_i, v_j \in V(G)$ non coincidenti, sarà necessario aggiornare $M_G[i, j]$ e $M_G[j, i]$.
\end{remark}

\begin{remark}[Eliminazione di un nodo]
    Per eliminare un nodo da un grafo indiretto, sarà necessario eliminare tutti i suoi collegamenti, e dunque il costo risulta essere $O(n)$, rimuovendo interamente la sua riga e la sua colonna.
\end{remark}

\begin{remark}[Controllo di adiacenza]
    Per controllare che $v_i, v_j \in V(G)$ non coincidenti siano adiacenti, sarà sufficiente controllare $M_G[i, j] = M_G[j, i]$, e dunque il costo di un controllo è $O(1)$.
\end{remark}

\subsection{Liste di adiacenza}

\begin{definition}[Liste di adiacenza]
    Sia $G = (V, E)$ un grafo; allora, è possibile rappresentare $G$ attraverso liste di adiacenza, salvando dunque una lista per ogni vertice, contenente i vertici ad esso adiacenti; in simboli $$\forall v \in V(G) \quad v:[\hat{v} \in V(G) - \{v\} \mid \hat{v} \sim v]$$
\end{definition}

\begin{remark}[Spazio delle liste]
    Dato un certo $v \in V(G)$, la lista di adiacenza corrispondente ha lunghezza $\deg(v)$; allora, il numero di elementi nelle liste di adiacenza, per il \cref{Somma dei gradi}, è pari a $\displaystyle O \left(\sum_{v \in V(G)}{\deg(v)}\right) = O\left( 2 |E(G)| \right)=O(2m) = O(m)$. Si noti inoltre che, per un grafo con pochi archi, nonostante si abbiano le liste poco riempite, è comunque necessario salvare i puntatori a tali liste, e dunque è necessario introdurre un $O(n)$ nel costo totale dello spazio, ottenendo allora $O(n) + O(m) = O(n + m)$.
\end{remark}

\begin{remark}[Controllo di adiacenza]
    Per controllare che due nodi $v, v' \in V(G)$ siano adiacenti, è necessario controllare, ad esempio, se $v'$ è contenuto nella lista di $v$, e dunque il costo per tale controllo è $O(\deg(v))$.
    Si noti che, nel caso peggiore, il grafo rappresentato da liste di adiacenza sarà composto da una sola lista per un certo $v \in V(G)$, contenente ogni altro vertice del grafo $\hat{v} \in V(G) - \{v\}$, e la lunghezza della lista di adiacenza di $v$ sarà $n - 1$. Di conseguenza, nel caso peggiore, il costo per controllare se due vertici sono adiacenti è $O(n)$.
\end{remark}

\begin{remark}[Eliminazione di un nodo]
    Per effettuare la rimozione di un nodo da un grafo, è necessario rimuoverlo da ogni lista di adiacenza in cui compare, e nel caso peggiore esso ha archi verso tutti gli altri nodi; allora, il costo di tale operazione è dato dal maggiore tra $n$ ed $m$, e dunque $O(n) + O(m) = O(n + m)$.
\end{remark}

\begin{remark}[Grafo diretto]
    Si noti che per grafi diretti è necessario effettuare una scelta di rappresentazione: all'interno delle liste è possibile salvare i vertici entranti, i vertici uscenti, o entrambi (assegnando due liste ad ogni vertice).
\end{remark}

\begin{example}[Rappresentazione di un grafo]
    Ad esempio, si consideri il seguente grafo $G$:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=4] {6};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (4) edge (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    allora, la sua corrispondente matrice di adiacenza è
    $$M_G = \left( \begin{array}{llllll}
        0 & 0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 1 & 0 & 0 \\
        0 & 1 & 0 & 1 & 0 & 0 \\
        1 & 1 & 1 & 0 & 1 & 1 \\
        0 & 0 & 0 & 1 & 0 & 1 \\
        0 & 0 & 0 & 1 & 1 & 0 \\
    \end{array} \right)$$

    mentre le corrispondenti liste di adiacenza sono $$\left \{ \begin{array}{l} 1: [4] \\ 2: [4, 3] \\ 3: [2, 4] \\ 4: [1, 3, 5, 6] \\ 5: [4, 6] \\ 6: [4, 5] \end{array} \right.$$
\end{example}

\section{Algoritmi}

\subsection{Trovare un ciclo}

\begin{algorithm}[H]
    \caption{
        Dato un grafo indiretto $G$, con ogni vertice avente grado almeno pari a $2$, l'algoritmo restiuisce un ciclo di $G$.\\
        \textbf{Input}: $G$ grafo indiretto, tale che $\forall v \in V(G) \quad \deg(v) \ge 2$.\\
        \textbf{Output}: un ciclo di $G$.
    }

    \begin{algorithmic}[1]
        \Function{findCycle}{$G$}
            \State $v \in V(G)$ \Comment{un vertice qualsiasi di $G$}
            \State $\texttt{visited} := \verb|{|v\verb|}|$ \Comment{conterrà i vertici visitati}
            \State $v' \in V(G) : v \sim v'$
            \While{$v' \notin \texttt{visited}$} \Comment{tempo costante perché \texttt{visited} è un set}
                \State $\texttt{visited.add(}v'\texttt{)}$
                \State $v' := v'' \in V(G) : \left \{ \begin{array}{l}v' \sim v'' \\ v'' \neq \texttt{visited[visited.length()} - 2\texttt{]} \end{array} \right.$
            \EndWhile
            \State \textbf{return} $\texttt{visited[visited.indexOf(}v'\texttt{)} \texttt{:} \texttt{visited.length()]}$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    L'algoritmo inizia scegliendo un qualsiasi vertice di $G$, denotato alla riga $2$ con $v$; successivamente, alla riga $3$ viene inizializzato un array \texttt{visited} che contterà tutti i vertici visitati attraverso l'algoritmo; inotre, alla riga $4$ viene scelto un altro vertice $v'$, che sia adiacente al $v$ di partenza.

    All'interno del ciclo \texttt{while}, alla riga $6$ l'algoritmo salva $v'$ all'interno dell'array di vertici visitati, mentre alla riga $7$ viene rimpiazzato $v'$, scegliendo un nuovo vertice, adiacente a $v'$, che sia diverso dal penultimo vertice inserito all'interno di \texttt{visited}. Il motivo per cui quest'ultimo controllo è necessario, è che il penultimo vertice inserito sarà il vertice dal quale $v'$ proveniva, di conseguenza si rischierebbe di ripercorrere uno stesso vertice più di una volta, e dunque non si formerebbe un ciclo. Si noti che è necessaria l'ipotesi per cui $G$ abbia ogni vertice di grado almeno pari a $2$, altrimenti non sarebbe possibile trovare un vertice differente dal penultimo di \texttt{visited}. Il ciclo termina nel momento in cui viene scelto un $v'$ già presente all'interno di \texttt{visited}, in quanto, poiché non è possibile ripercorrere i propri passi, l'unica possibilità in cui si è giunti ad un vertice già visitato è se si è concluso un ciclo.
    
    L'algoritmo termina restituendo uno slice dell'array, partendo dal primo indice di $v'$ disponibile (si noti che alla fine dell'algoritmo anche l'ultimo elemento di \texttt{visited} sarà $v'$), fino alla fine.
\end{remark}

\begin{remark}
    Si noti che \texttt{visited} contiene tutti i nodi visitati, dunque restituire interamente l'array potrebbe non fornire un ciclo, come nel seguente grafo
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto contenente un ciclo.}
    \end{figure}

    in cui, ad esempio partendo da $v= 4$, l'unico ciclo è $$\{4, (4, 3), 3, (3, 2), 2, (2, 4), 4\}$$ nonostante al termine dell'algoritmo si avrebbe $\texttt{visited}=[1, 4, 3, 2, 4]$, che non costituisce un ciclo.

\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Il costo di questo algoritmo dipende dalla struttura dati utilizzata per rappresentare il grafo in input: nel caso in cui $G$ è rappresentato attraverso una matrice di adiacenza, il costo del ciclo \texttt{while} è pari a $O(n)$, poiché la riga $7$ richiede di trovare un $v'' \in V(G) : v' \sim v''$, il ché potrebbe portare a dover scorrere tutta la riga/colonna di $v''$, dunque nel caso peggiore $O(n)$; differentemente, rappresentando $G$ attraverso liste di adiacenza, basta scegliere il primo vertice contenuto nella lista di $v''$, e se questo dovesse coincidere con il penultimo elemento di \texttt{visited}, sarà sufficiente scegliere il secondo elemento della lista (sicuramente presente per come $G$ è scelto in ipotesi), dunque si ha $O(2) = O(1)$.

    Infine, si noti che il ciclo \texttt{while} ha costo $O(n)$, poiché nel caso peggiore si ha un ciclo che percorre tutto il grafo.

    Allora, tramite matrice l'algoritmo ha costo $O(n) \cdot O(n) = O(n^2)$, mentre tramite liste si ha $O(1) \cdot O(n) = O(n)$.
\end{remark}

\subsection{DFS (Depth-First Search)}

\begin{definition}[DFS]
    Con DFS si indica il criterio di visita di un grafo; in particolare, DFS sta per \textit{Depth-First Search}, dunque la visita del grafo avviene procendendo sempre più in profondità, retrocedendo esclusivamente se non è più possibile avanzare.
\end{definition}

\begin{algorithm}[H]
    \caption{
        Prima versione dell'algoritmo; dato un grafo indiretto $G$, e un suo vertice $v$, l'algoritmo restituisce tutti i vertici, raggiungibili attraverso cammini, partendo da $v$.\\
        \textbf{Input}: $G$ grafo indiretto; $v$ un vertice di $G$.\\
        \textbf{Output}: i vertici raggiungibili da $v$.
    }

    \begin{algorithmic}[1]
        \Function{findReachableNodes$_1$}{$G$, $v$}
            \State $\texttt{visited}:=\texttt{[}0\texttt{]} * n$ \Comment{array di $n$ zeri}
            \State $\texttt{visited[}v\texttt{]} = 1$
            \State $\texttt{Stack S}:=\texttt{[}v\texttt{]}$
            \While{$!\texttt{S.isEmpty()}$}
                \State $v_{top}=\texttt{S.top()}$
                \If{$\exists z \in V(G) : \left \{ \begin{array}{l}z \sim v_{top} \\ \texttt{visited[}z\texttt{]}=0 \end{array} \right.$}
                    \State $\texttt{S.push(}z\texttt{)}$
                    \State $\texttt{visited[}z\texttt{]} = 1$
                \Else
                    \State $\texttt{S.pop()}$
                \EndIf
            \EndWhile
            \State \textbf{return} \texttt{visited}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{proof}
    Per assurdo, sia $\hat v \in V(G)$, raggiungibile da $v$ attraverso un cammino, che non sia stato raggiunto dall'algoritmo; allora, per definizione esiste un cammino $v, e_1, v_1, \ldots, v_{n - 1}, v_n, \hat v$; inoltre, sia $v_i$ il vertice con indice maggiore all'interno del cammino, raggiunto dall'algoritmo, e dunque avendo che $\left \{ \begin{array}{l}v_i \sim v_{i + 1} \\ v_{i + 1} \notin \texttt{visited}  \end{array} \right.$. Allora, per costruzione dell'algoritmo, $v_i$ sarebbe stato rimosso dallo stack, alla riga $11$, prima che $v_{i + 1}$ potesse essere visitato; ma poiché $v_i \sim v_{i +1}$, allora l'algoritmo dovrebbe aver sbagliato esecuzione, poiché $v_{i +1}$ sarebbe stato raggiunto alla riga $7$ inevitabilmente $\lightning$.
\end{proof}

\begin{remark}[Costo dell'algoritmo]
    Si consideri $G$ rappresentato attraverso matrice di adiacenza; allora, il costo della riga $7$, nel caso peggiore, è $O(n)$, poiché è necessario controllare tutta la riga/colonna di $v_{top}$ per trovare un vertice $z$ tale che $\texttt{visited[}z\texttt{]} = 0$, dunque non sia stato ancora visitato. Per ragione analoga, rappresentando $G$ attraverso liste di adiacenza, nel caso peggiore si ha una sola lista corrispondente ad un singolo vertice di $G$, e sarà dunque necessario effettuare $O(n - 1) = O(n)$ controlli.

    Inoltre, si noti che il caso peggiore dell'algoritmo si ha quando $v$ può raggiungere ogni altro nodo di $G$, e dunque il ciclo \texttt{while} sarà ripetuto $O(2n - 1) = O(2n) = O(n)$ volte, poiché ogni vertice verrà inserito e rimosso dallo stack, eccetto il primo, inserito alla riga $4$.

    Allora, il costo complessivo dell'algoritmo, indipendentemente dalla rappresentazione di $G$, è pari a $O(n) \cdot O(n) = O(n^2)$.
\end{remark}

\begin{remark}[Albero]
    \label{Sottografo di un grafo indiretto}
    Sia $G$ un grafo indiretto; considerando l'insieme di archi attraversati dall'algoritmo per trovare ogni vertice raggiungibile partendo da $v$, al termine della procedura si ottiene un sottografo indiretto di $G$ connesso ed aciclico: connesso, poiché l'algoritmo procede per adiacenza di vertici, ed aciclico, poiché l'algoritmo non visita lo stesso vertice più di una volta. Allora, per definizione, tale sottografo è un albero.
\end{remark}

\begin{remark}[Grafo diretto]
    Si noti che l'algoritmo è valido anche per grafi diretti.
\end{remark}

\begin{remark}[Arborescenza]
    Sia $G$ un grafo diretto; considerando l'insieme di archi attraversati dall'algoritmo per trovare ogni vertice raggiungibile partendo da $v$, al termine della procedura si ottiene un sottografo diretto di $G$ connesso ed aciclico, per gli stessi motivi dell'\cref{Sottografo di un grafo indiretto}; tale sottografo è un arborescenza di $v$.
\end{remark}

\begin{algorithm}[H]
    \caption{
        Seconda versione dell'algoritmo; dato un grafo indiretto $G$, rappresentato attraverso liste di adiacenza, e un suo vertice $v$, l'algoritmo restituisce tutti i vertici, raggiungibili attraverso cammini, partendo da $v$.\\
        \textbf{Input}: $G$ grafo indiretto, rappresentato attraverso liste di adiacenza; $v$ un vertice di $G$.\\
        \textbf{Output}: i vertici raggiungibili da $v$.
    }

    \begin{algorithmic}[1]
        \Function{findReachableNodes$_2$}{$G$, $v$}
            \State $\texttt{visited} := \verb|{|v\verb|}|$
            \State $\texttt{Stack S} := \texttt{[}v\texttt{]}$
            \While{$!\texttt{S.isEmpty()}$}
                \State $v_{top}=\texttt{S.top()}$
                \While{$!v_{top}\texttt{.adjacent().isEmpty()}$}
                    \State $z := v_{top}\texttt{.adjacent()[}0\texttt{]}$
                    \State $v_{top}\texttt{.adjacent().remove(}0\texttt{)}$ \Comment{fa la differenza}
                    \If{$z \notin \texttt{visited}$}
                        \State $\texttt{visited.add(}z\texttt{)}$
                        \State $\texttt{S.push(}z\texttt{)}$
                        \State \textbf{break}
                    \EndIf
                \EndWhile
                \If{$v_{top}\texttt{ == S.top()}$}
                    \State \texttt{S.pop()}
                \EndIf
            \EndWhile
            \State \textbf{return} \texttt{visited}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}(Differenze con la prima versione)
    Questa seconda versione dell'algoritmo presenta una miglioria sostanziale alla riga $8$: infatti, attraverso questa riga si rimuovono di volta in volta i vertici adiacenti appena già visitati; di conseguenza, i vertici adiacenti da controllare saranno progressivamente sempre meno. Infatti, si noti che senza la riga $8$, l'algoritmo si comporterebbe come la prima versione.

    Il \texttt{break} alla riga $12$ interrompe il ciclo \texttt{while} della riga $6$, facendo sì che $v_{top}$ della riga $5$, all'iterazione successiva del \texttt{while} della riga $4$, sia pari a $z$, dunque cambiando il vertice correntemente in esame. Di conseguenza, alla riga $15$ il controllo sarà valutato a \texttt{true} esclusivamente se non è mai stata eseguita la riga $11$ per tutta l'iterazione del ciclo \texttt{while} della riga $6$, ovvero quando tutti i vertici adiacenti a $v_{top}$ sono già stati visitati.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Poiché i nodi visitati vengono eliminati, il costo del ciclo \texttt{while} dipende da operazioni eseguite in tempo costante $O(1)$, e da quanti nodi vengono controllati per ogni iterazione del ciclo, ma poiché non si possono ricontrollare più volte gli stessi nodi, allora il costo del ciclo dipende solamente dalla dimensione delle liste di adiacenza, e dunque si ha $\displaystyle O\left( \sum_{v \in V(G)}{O(1) + \deg(v)}\right)=O\left(\sum_{v \in V(G)}{O(1)}\right) + O\left(\sum_{v \in V(G)}{\deg(v)}\right) = O(n) + O(m) = O(n+ m)$, per il \cref{Somma dei gradi}.
\end{remark}

\begin{remark}[Grafo diretto]
    Per estendere questo algoritmo a grafi diretti, è necessario fornire in input un grafo rappresentato attraverso liste di adiacenza, le quali devono contenere esclusivamente i vertici uscenti, poichè sono gli unici archi percorribili.
\end{remark}

\subsection{Trovare un ordinamento topologico}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto aciclico $G$, l'algoritmo restituisce un suo ordinamento topologico.\\
        \textbf{Input}: $G$ grafo diretto aciclico.\\
        \textbf{Output}: un ordinamento topologico di $G$.
    }

    \begin{algorithmic}[1]
        \Function{findTopologicalSorting}{$G$}
            \State $\texttt{order} := \texttt{[}\texttt{]}$
            \While{$V(G) \neq 0$}
                \State $v \in V(G) : v.\texttt{incoming\_adjacent().length()} = 0$
                \State $\texttt{order.append(}v\texttt{)}$
                \State $V(G)\texttt{.remove(}v\texttt{)}$
            \EndWhile
            \State \textbf{return} \texttt{order}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}(Costo dell'algoritmo)
    Il ciclo \texttt{while} della riga $3$, indipendentemente dalla struttura di rappresentazione del grafo $G$, deve essere eseguito $n$ volte, e dunque ha costo $O(n)$, poiché l'ordinamento topologico deve coinvolgere ogni nodo del grafo, e alla riga $6$ i nodi controllati vengono progressivamente rimossi.

    Rappresentando $G$ attraverso matrice di adiacenza, indicando con $1$ i vertici adiacenti entranti, il costo della riga $4$ è pari a $O(n^2)$, poiché per trovare un vertice $v$ che non abbia archi entranti, è necessario controllare tutta la sua riga/colonna, e dunque nel caso peggiore, per trovarlo sarà necessario controllare l'intera matrice; inoltre, per effettuare la rimozione di $v$ alla riga $6$, il costo è $O(n)$, Allora, il costo complessivo dell'algoritmo risulta essere $O(n) \cdot [O(n^2) + O(n)]= O(n) \cdot O(n^2) = O(n^3)$.

    Differentemente, rappresentando $G$ attraverso liste di adiacenza, salvando solamente i vertici adiacenti entranti per ogni nodo, alla riga $4$ per trovare un nodo senza archi entranti è sufficiente controllare il numero di elementi della lista di ogni vertice, operazione a costo $O(1)$, e dunque il costo, nel caso peggiore, è $O(n - 1) = O(n)$; inoltre, per rimuovere $v$ alla riga $6$, il costo è pari a $O(n + m)$. Allora, il costo complessivo dell'algoritmo risulta essere $O(n) \cdot [O(n) + O(n + m)] = O(n) \cdot [O(2n + m)] = O(n) \cdot O(n + m) = O(n \cdot (n +m))$.
\end{remark}

\subsection{Tempi di visita e di chiusura}

\begin{definition}[Tempo di visita e di chiusura]
    All'interno degli algoritmi che visitano grafi secondo DFS, è possibile introdurre un \texttt{counter} inizializzato ad $1$, ed incrementato ogni volta che viene attraversato un \textit{nuovo} vertice.

    Allora, per ogni vertice $v$ del grafo diretto in input, si definiscono $t(v)$, detto \textit{tempo di visita di $v$}, pari al valore del \texttt{counter} la prima volta che $v$ viene visitato, e $T(v)$, detto \textit{tempo di chiusura di $v$}, pari al valore del \texttt{counter} nel momento in cui $v$ viene rimosso dallo stack.

    Inoltre, si definisce $\mathrm{Int}(v) := [t(v), T(v)]$.
\end{definition}

\begin{remark}[Intervalli delle foglie]
    Si noti che per ogni foglia $v$ del grafo, ovvero i vertici per i quali non è più possibile scendere di profondità, si ha $t(v) = T(v)$, per definizione stessa dei tempi.
\end{remark}

\begin{lemma}[Proprietà degli intervalli]
    \label{Intervalli diretto}
    Sia $G$ un grafo diretto, e $u, v \in V(G)$ adiacenti; allora solo una delle seguenti proposizioni è vera:
    \begin{enumerate}[i)]
        \item $\mathrm{Int}(u) \subseteq \mathrm{Int}(v)$
        \item $\mathrm{Int}(v) \subseteq \mathrm{Int}(u)$
        \item $\mathrm{Int}(u) \cap \mathrm{Int}(v) = \varnothing$
    \end{enumerate}
    
    Dunque, gli intervalli o sono l'uno interamente contenuto nell'altro, o non si intersecano.
\end{lemma}

\begin{proof}
    La tesi equivale a dimostrare che non può verificarsi il caso in cui c'è intersezione non vuota tra i due intervalli, e dunque non è possibile che $\mathrm{Int}(u) \cap \mathrm{Int}(v) \neq \varnothing$, ovvero $t(u) < t(v) < T(u) < T(v)$, allora:

    \begin{itemize}
        \item $t(u) < t(v) \implies u$ inserito nello stack prima di $v$
        \item $t(v) < T(u) \implies u$ viene rimosso dallo stack dopo aver visitato $v$, ma poiché $u$ era sotto a $v$ all'interno dello stack, necessariamente $v$ deve essere stato rimosso dallo stack prima di $u$, e allora non è possibile che $T(u) < T(v) \ \lightning$.
    \end{itemize}
    
    Si noti che, avendo ad esempio $(u, v) \in E(G)$, e dunque $u$ incidente a $v$, allora necessariamente $\mathrm{Int}(u) \cap \mathrm{Int}(v) \implies t(v) < T(v) < t(u) \le T(u)$.
\end{proof}

\begin{remark}[Categorie di archi]
    Sia $G= (V, E)$ un grafo diretto, $\hat v \in V(G)$, e sia $A_{\hat v}$ la sua arborescenza; allora, è possibile classificare ogni arco $(u, v) \in E(G) - E(A_{\hat v})$, mediante $\mathrm{Int}(u)$ e $\mathrm{Int}(v)$:
    \begin{itemize}
        \item $\mathrm{Int}(u) \subseteq \mathrm{Int}(v)$, allora l'arco $(u, v)$ è un \textit{backward edge}, ovvero in avanti: sono gli archi che congiungono due nodi dello stesso ramo di $A_{\hat v}$, nel caso in cui $v$ è più in profondità di $u$ nella visita DFS 
        \item $\mathrm{Int}(v) \subseteq \mathrm{Int}(u)$, allora l'arco $(u, v)$ è un \textit{forward edge}, ovvero all'indietro: sono gli archi che congiungono due nodi dello stesso ramo di $A_{\hat v}$, nel caso in cui $u$ è più in profondità di $v$ nella visita DFS
        \item $\mathrm{Int}(v) \cap \mathrm{Int}(u) = \varnothing$, allora l'arco $(u, v)$ è un \textit{cross edge}, detto \textit{arco di attraversamento}: sono gli archi che congiungono due nodi di rami differenti in $A_{\hat v}$
    \end{itemize}
\end{remark}

\begin{lemma}[Proprietà degli intervalli]
    Sia $G$ un grafo indiretto, e $u, v \in V(G)$ adiacenti; allora si verifica una sola tipologia di inclusione, in cui $\mathrm{Int}(u) \subseteq \mathrm{Int}(v)$, oppure $\mathrm{Int}(v) \subseteq \mathrm{Int}(u)$, e poiché gli archi non sono orientati perde di significato la distinzione tra i due casi.
\end{lemma}

\begin{proof}
    La tesi equivale a dimostrare che non può verificarsi il caso in cui c'è intersezione vuota tra i due intervalli, e dunque non è possibile che $\mathrm{Int}(u) \cap \mathrm{Int}(v) = \varnothing$, ovvero $t(u) \le T(u) < t(v) \le T(v)$, poiché $T(u) < t(v)$ implicherebbe che $u$ verrebbe rimosso dallo stack prima che $v$ possa essere inserito, e questo non è possibile per costruzione della visita DFS, poiché $u \sim v$.
\end{proof}

\begin{remark}[Categorie di archi]
    Sia $G=(V, E)$ un grafo indiretto, $\hat v \in V(G)$, e sia $T_{\hat v}$ il suo albero; allora, ogni arco $(u, v) \in E(G) - E(T_{\hat v})$ viene classificato come \textit{backward edge}.
\end{remark}

\begin{theorem}[Presenza di cicli]
    Sia $G$ un grafo indiretto connesso; allora $G$ ha un ciclo se e solo se in esso esiste un backward edge in ogni albero.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Per assurdo, sia $G$ un grafo indiretto, in cui è presente almeno un ciclo, e non sono presenti backward edge; inoltre, sia $\hat v \in V(G)$, e sia $T_{\hat v}$ il suo albero. Allora, poiché $G$ non ha backward edge, necessariamente gli unici suoi archi sono quelli che compongono $T_{\hat v}$, e dunque $E(G) = E(T_{\hat v}) \implies G = T_{\hat v} \implies G$ è un albero, e dunque $G$ non ha cicli $\lightning$.
        \item[] \textit{Seconda implicazione.} Sia $G$ un grafo indiretto connesso, sia $\hat v \in V(G)$, $T_{\hat v}$ il suo albero, e sia $(u, v) \in E(G) - E(T_{\hat v})$ un backward edge. Allora, poiché $u, v \in V(T_{\hat v})$, è sufficiente considerare il cammino tale che $u \rightarrow v$, che esiste poiché $T_{\hat v}$ è un albero, e dunque $\{u \rightarrow v\} \cup (u, v)$ è un ciclo di $G$.
    \end{itemize}
\end{proof}

\begin{theorem}[Presenza di cicli]
    \label{Cicli diretto}
    Sia $G$ un grafo diretto connesso; allora $G$ ha un ciclo se e solo se in esso esiste un backward edge in almeno un'arborescenza.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} TODO
        \item[] \textit{Seconda implicazione.} Sia $G$ un grafo diretto fortemente connesso, e sia $\hat v \in V(G)$ tale che la sua arborescenza $A_{\hat v}$ contenga un backward edge $(u, v) \in E(G) - E(A_{\hat v})$. Allora, poiché $u, v \in V(T_{\hat v})$, e $(u, v)$ è un backward edge, è sufficiente considerare il cammino tale che $u \rightarrow v$, che esiste poiché $A_{\hat v}$ è un arborescenza, e dunque $\{u \rightarrow v\} \cup (u, v)$ è un ciclo di $G$. Si noti che il fatto che $G$ sia fortemente connesso garantisce di poter considerare un $\hat v \in V(G)$ qualsiasi.
    \end{itemize}
\end{proof}

\begin{corollary}
    Sia $G$ un grafo diretto aciclico connesso, sia $\hat v \in V(G)$ un suo vertice, sia $A_{\hat v}$ la relativa arborescenza, e sia $(u, v) \in E(G)$ un arco; allora $t(v) \le T(u)$.
\end{corollary}

\begin{proof}
    Si noti che ogni arco $(u, v) \in A_{\hat v}$ è un forward edge per costruzione della visita DFS; allora si consideri il caso in cui $(u, v) \in E(G) - A_{\hat v}$. Allora per il teorema precedente, $(u, v)$ non è un backward edge, e dunque per il \cref{Intervalli diretto} si può verificare solo una delle seguenti:
    \begin{itemize}
        \item $\mathrm{Int}(v) \subseteq \mathrm{Int}(u) \implies t(u) < t(v) \le T(v) < T(u)$, e in particolare $t(v) \le T(u)$
        \item $\mathrm{Int}(u) \cap \mathrm{Int}(v) = \varnothing \implies t(v) < T(v) < t(u) < T(u)$, e in particolare $t(v) \le T(u)$.
    \end{itemize}
\end{proof}

\begin{corollary}
    Sia $G$ un grafo diretto aciclico connesso, sia $\hat v \in V(G)$ un suo vertice, sia $A_{\hat v}$ la relativa arborescenza, e sia $(u, v) \in E(G)$ un arco; allora $T(v) \le T(u)$.
\end{corollary}

\begin{proof}
    Per il corollario precedente, per ogni arco di un grafo indiretto aciclico connesso $t(v) \le T(u)$, allora:
    \begin{itemize}
        \item $t(v) < t(u)$: se $T(u) \le T(v)$, allora $(u, v)$ sarebbe un backward edge, che non è possibile avere per il \cref{Cicli diretto}; allora necessariamente $T(v) < T(u)$; ma se $t(u) < T(v)$ allora si avrebbe intersezione non vuota tra gli intervalli, impossibile per il \cref{Intervalli diretto}; allora necessariamente $t(v) < T(v) < t(u) < T(u)$, e dunque $(u, v)$ è un cross edge
        \item $t(u) < t(v)$: se $T(u) < T(v)$, allora gli intervalli avrebbero intersezione non vuota, e ciò non si può verificare per il \cref{Intervalli diretto}; allora necessariamente $t(u) < t(v) \le T(v) \le T(u)$, e dunque $(u, v)$ è un forward edge.
    \end{itemize}

    In particolare, si ha che $T(v) \le T(u)$ in entrambe i casi.
\end{proof}

\begin{theorem}[Ordinamento topologico attraverso i tempi]
    Sia $G$ un grafo diretto aciclico connesso, sia $\hat v \in V(G)$ un suo vertice, e sia $A_{\hat v}$ la sua arborescenza; allora, ordinando i vertici attraverso i loro tempi di chiusura $T$ in ordine decrescente, si ottiene un ordinamento topologico del grafo.
\end{theorem}

\begin{proof}
    Per definizione, un'ordinamento è detto topologico se ogni vertice è posto prima dei suoi archi uscenti; inoltre, per il corollario precedente, per ogni $(u, v) \in E(G)$ si ha $T(v) \le T(u)$, e dunque se si ordinassero i vertici di $G$ utilizzando i tempi di chiusura $T$, in ordine crescente, come criterio, allora $v$ verrebbe prima di $u$, e $(u, v)$ è un arco diretto in cui $u$ è incidente a $v$; allora, segue che ordinando i vertici in ordine decrescente di $T$, si ha un ordinamento topologico di $G$.
\end{proof}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto aciclico connesso $G$, rappresentato attraverso liste di adiacenza in cui vengono salvati gli archi adiacenti uscenti, l'algoritmo restituisce un ordinamento topologico di $G$.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso liste di adiacenza.\\
        \textbf{Output}: un ordinamento topologico di $G$.
    }

    \begin{algorithmic}[1]
        \Function{DFS}{$G$, $v$, \texttt{visited}, \texttt{order}}
            \State $\texttt{visited.add(}v\texttt{)}$
            \For{$u \in V(G) : (v, u) \in E(G)$} \Comment{$u$ deve essere uscente da $v$}
                \If{$u \notin \texttt{visited}$}
                    \State $\texttt{DFS(}G, u, \texttt{visited},\texttt{order)}$
                \EndIf
            \EndFor
            \State $\texttt{order.append(}v\texttt{)}$ \Comment{l'ordinamento risulterà invertito}
        \EndFunction
        \\
        \Function{findTopologicalSortingDFS}{$G$}
            \State $\texttt{order} := \texttt{[]}$
            \State $\texttt{visited} := \texttt{[]}$
            \For{$v \in V(G)$}
                \If{$v \notin \texttt{visited}$}
                    \State $\texttt{DFS(}G, v, \texttt{visited},\texttt{order)}$
                \EndIf
            \EndFor
            \State $\texttt{order.reverse()}$ \Comment{viene invertita la lista}
            \State \textbf{return} \texttt{order}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Ordinamento topologico]
    Si noti che l'algoritmo non salva i tempi di chiusura dei vari vertici per ordinarli, ma non è necessario grazie alla ricorsione: infatti, inserendo il vertice alla riga $8$, dunque dopo il loop \texttt{for}, l'inserimento avviene in post-order rispetto alla visita del grafo, e dunque è equivalente a rispettare l'ordinamento crescente dei tempi di chiusura di ogni nodo. Dunque, è sufficiente invertire la lista ottenuta, alla riga $19$, per ottenere un ordinamento topologico.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Si noti che l'algoritmo ha costo $O(n + m)$, poiché attua una sola visita in DFS del grafo, rappresentato attraverso liste di adiacenza, ricorsivamente.
\end{remark}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto $G$, rappresentato attraverso liste di adiacenza (per ogni vertice sono salvate due liste, dei vertici entranti e dei vertici uscenti), e un suo vertice $v$, l'algoritmo restituisce gli archi non facenti parti dell'arborescenza di $v$, categorizzati in base ai loro intervalli di apertura e chiusura.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso liste di adiacenza; $v$ un vertice di $G$.\\
        \textbf{Output}: archi non dell'arborescenza, categorizzati per intervalli.
    }

    \begin{algorithmic}[1]
        \Function{categorizeEdges}{$G$, $v$}
            \State $\texttt{visited} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{visited[}v\texttt{]}=1$
            \State $\texttt{Stack S}:=\texttt{[}v\texttt{]}$
            \State $\texttt{c}:=1$
            \State $\texttt{t} := \texttt{[}0\texttt{]} * n$ \Comment{tempi di visita}
            \State $\texttt{T} := \texttt{[}0\texttt{]} * n$ \Comment{tempi di chiusura}
            \State $\texttt{t[}v\texttt{]}=\texttt{c}$
            \State $\texttt{parents} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{parents[}v\texttt{]}=v$ \Comment{per riconoscere la radice}
            \While{$!\texttt{S.isEmpty()}$}
                \State $v_{top} := \texttt{S.top()}$
                \While{$!v_{top}\texttt{.outgoing\_adjacent().isEmpty()}$}
                    \State $z:=v_{top}\texttt{.outgoing\_adjacent()[}0\texttt{]}$
                    \State $v_{top}\texttt{.outgoing\_adjacent().remove(}0\texttt{)}$
                    \If{$z \notin \texttt{visited}$}
                        \State $\texttt{visited[}z\texttt{]}=1$
                        \State $\texttt{S.push(}z\texttt{)}$
                        \State $\texttt{parents[}z\texttt{]}=v_{top}$
                        \State $\texttt{c +=}1$
                        \State $\texttt{t[}z\texttt{]}=\texttt{c}$
                        \State \textbf{break}
                    \EndIf
                \EndWhile
                \If{$v_{top}\texttt{ == S.top()}$}
                    \State \texttt{S.pop()}
                    \State $\texttt{T[}v_{top}\texttt{]}=\texttt{c}$
                \EndIf
            \EndWhile
            \algstore{bkbreak}
    \end{algorithmic}
\end{algorithm}

\begin{nocaptionalg}
    \begin{algorithmic}[1]
            \algrestore{bkbreak}
            \State $\texttt{forward} := \texttt{[]}$
            \State $\texttt{backward} := \texttt{[]}$
            \State $\texttt{cross} := \texttt{[]}$

            \For{$v \in V(G)$}
                \For{$u \in v\texttt{.incoming\_adjacent()}$}
                    \If{$\texttt{parents[}v\texttt{]}==u$}
                        \State \textbf{continue} \Comment{faceva parte dell'arborescenza di $v$}
                    \ElsIf{$\texttt{T[}u\texttt{]} < \texttt{t[}v\texttt{]} \ \texttt{or} \ \texttt{T[}v\texttt{]} < \texttt{t[}u\texttt{]}$}
                        \State $\texttt{cross.add(}(u, v)\texttt{)}$
                    \ElsIf{$\texttt{T[}u\texttt{]} \le \texttt{T[}v\texttt{]}$}
                        \State $\texttt{backward.add(}(u, v)\texttt{)}$
                    \Else
                        \State $\texttt{forward.add(}(u, v)\texttt{)}$
                    \EndIf
                \EndFor
            \EndFor

            \State \textbf{return} \texttt{forward}, \texttt{backward}, \texttt{cross}
        \EndFunction
    \end{algorithmic}
\end{nocaptionalg}

\begin{remark}[Costo dell'algoritmo]
    TODO O(n +m)
\end{remark}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto $G$, rappresentato attraverso matrice di adiacenza, l'algoritmo restituisce, se presente, il pozzo universale di $G$.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso matrice di adiacenza.\\
        \textbf{Output}: il pozzo universale di $G$, se presente.
    }

    \begin{algorithmic}[1]
        \Function{findUniversalSink}{$G$, $v$}
            \State TODO
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Costo dell'algoritmo]
    TODO O(n)
\end{remark}

\end{document}
