% === BEGIN TEMPLATE ===

% !!!THE ORDER MATTERS, DON'T CHANGE THE ORDER OF PACKAGES!!!

\documentclass[14pt]{extreport}

% misc
\usepackage[italian]{babel} % set the language to italian
\usepackage{indentfirst} % spacing at the beginning of every paragraph
\usepackage[margin = 1.0in]{geometry} % size of the margins

% tools
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage[capitalize,nameinlink,italian]{cleveref}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{stmaryrd}
\let\stmaryrdLightning\lightning
\hypersetup{colorlinks,linkcolor={red!50!black},citecolor={blue!50!black},urlcolor={blue!80!black}} % change the colors of cleveref
\usepackage{float}
\usepackage[Algoritmo]{algorithm}
\usepackage{algpseudocode}
\counterwithin{algorithm}{subsection}
\newenvironment{nocaptionalg} % environment for algorithms without caption
{
    \par\addvspace{\topsep}
    \centering
    \begin{minipage}{\linewidth}
    \hrule\kern2pt
}
{
    \par\kern2pt\hrule
    \end{minipage}
    \par\addvspace{\topsep}
}

% theorems
\newtheorem{theorem}{Teorema}[subsection]
\newtheorem{corollary}{Corollario}[subsection]
\newtheorem{lemma}{Lemma}[subsection]
\theoremstyle{definition}
\newtheorem{definition}{Definizione}[subsection]
\theoremstyle{definition}
\newtheorem{remark}{Osservazione}[subsection]
\newtheorem{example}{Esempio}[subsection]

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm}

    \textbf{\huge Progettazione di Algoritmi}

    \vspace{1.5cm}

    \textit{\Large Alessio Bandiera}

    \vfill
        
    \large Informatica, La Sapienza
\end{titlepage}

\tableofcontents

\pagebreak

% === END TEMPLATE ===

\chapter{Elementi di teoria dei grafi}

\section{Grafi}

\subsection{Definizioni}

\begin{definition}[Grafo]
    Un grafo è una struttura matematica descritta da vertici, collegati da archi. Un grafo viene descritto formalmente come $G=(V, E)$, dove i $v \in V$ sono i \textit{vertici} o \textit{nodi} del grafo, mentre gli $e \in E$ sono gli \textit{archi} (dall'inglese \textit{edges}). In particolare, $V(G)$ è l'insieme dei vertici di $G$, comunemente indicato con $n$, mentre $E(G)$ è l'insieme degli archi di $G$, comunemente indicato con $m$. Presi due vertici $v_1,v_2 \in V(G)$, allora $(v_1, v_2) \in E(G)$ è l'arco che li collega.
\end{definition}

\begin{remark}
    $E(G) \subseteq V^2$.
\end{remark}

\begin{definition}[Vertici adiacenti]
    $v_1, v_2 \in V(G)$ sono detti \textit{adiacenti} se $(v_1, v_2) \in E(G)$; in tal caso, si usa la notazione $v_1 \sim v_2$.
\end{definition}

\begin{definition}[Sottografo]
    Dato un grafo $G = (V, E)$, un sottografo $G'$ di $G$ è un grafo della forma $G' = (V', E'): \left \{ \begin{array}{l} V' \subseteq V \\ E' \subseteq E \end{array} \right.$. Si noti che $G$ è sottografo di sè stesso.
\end{definition}

\begin{definition}[Grafo indiretto]
    Un grafo è detto \textit{indiretto} se gli archi non hanno direzione, o equivalentemente $$\forall v_1, v_2 \in V(G) \quad (v_1, v_2) = (v_2, v_1) \in E(G)$$
\end{definition}

\begin{example}[Grafo indiretto]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (4) [below left of=5] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (1)
                (6) edge (3)
                (6) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si hanno $$V(G) = \{1, 2, 3, 4, 5, 6\}$$ $$E(G) = \{(1, 2), (1, 4), (1, 5) (2, 3), (2, 4), (3, 4), (3, 6), (5, 6)\}$$
\end{example}

\begin{definition}[Grafo diretto]
    Un grafo è detto \textit{diretto} se gli archi hanno direzione, o equivalentemente $$\forall v_1, v_2 \in V(G) \quad (v_1, v_2) \neq (v_2, v_1) \in E(G)$$
\end{definition}

\begin{example}[Grafo diretto]
    Ad esempio, si consideri questo grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (4) [below left of=5] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (1)
                (6) edge (3)
                (6) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    in esso, si hanno $$V(G) = \{1, 2, 3, 4, 5, 6\}$$ $$E(G) = \{(1, 2), (2, 3), (2, 4), (3, 4), (4, 1), (5, 1), (6, 3), (6, 5)\}$$
\end{example}

\begin{definition}[Grado]
    Il \textit{grado} di un vertice $v \in V(G)$ è il numero di archi incidenti su $v$, indicato con $\deg(v)$.
\end{definition}

\begin{lemma}[Somma dei gradi]
    \label{Somma dei gradi}
    Dato un grafo $G$, la somma dei gradi dei vertici è pari a $2 |E(G)|$.
\end{lemma}

\begin{proof}
    Sia $G$ un grafo. Allora, ogni arco $e \in E(G)$ collega due vertici; allora necessariamente $\displaystyle \sum_{v \in V(G)}{\deg(v)} = 2 |E(G)|$.
\end{proof}

\begin{definition}[Cappio]
    Un arco con estremi coincidenti è detto \textit{cappio}.
\end{definition}

\begin{example}[Grafo con cappio]
    Un esempio di grafo con cappio è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (1)
                (3) edge [loop below] (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto con cappio in 3.}
    \end{figure}
\end{example}

\begin{definition}[Grafo semplice]
    Un grafo è detto \textit{semplice} se non contiene cappi, né lati multipli, ovvero più archi per due vertici.

    All'interno di questi appunti, a meno di esplicita specifica, si assume che ogni grafo trattato sia semplice.
\end{definition}

\subsection{Visite}

\begin{definition}[Passeggiata]
    Una \textit{passeggiata} è una sequenza di vertici ed archi, della forma $\{v_0, e_1, v_1, e_2, \ldots , e_{k - 1}, v_{k - 1}, e_k, v_k\}$, dove $e_i=(v_{i - 1}, v_i)$. È la visita di un grafo più generale, ed è possibile ripercorrere ogni arco ed ogni vertice.
\end{definition}

\begin{remark}
    La lunghezza massima di una passeggiata su un grafo è infinita.
\end{remark}

\begin{definition}[Passeggiata chiusa]
    Una passeggiata si dice \textit{chiusa} se è della forma $\{v_0, e_1, v_1, e_2, \ldots , e_{k - 1}, v_{k - 1}, e_k, v_0\}$, dunque il primo e l'ultimo vertice coincidono. 
\end{definition}

\begin{definition}[Traccia]
    Una \textit{traccia} è una passeggiata aperta, in cui non è possibile ripercorrere gli archi, ma è possibile ripercorrere i vertici.
\end{definition}

\begin{example}[Traccia di un grafo]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=4] {6};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (4) edge (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si ha la traccia $$\{5, (5,4), 4, (4,3), 3, (3, 2), 2, (2,4), 4, (4, 6), 6\}$$
\end{example}

\begin{definition}[Circuito]
    Un \textit{circuito} è una traccia chiusa.
\end{definition}

\begin{definition}[Cammino]
    Un \textit{cammino} è una traccia aperta, in cui non è possibile ripercorrere i vertici. In simboli, dati $v, v' \in V(G)$, con $v \rightarrow v'$ si indica che è possibile raggiungere $v'$, partendo da $v$, attraverso un cammino; inoltre, è possibile estendere tale sintassi anche agli archi.
\end{definition}

\begin{remark}
    In una passeggiata in cui non si ripercorrono i vertici, non è possibile ripercorrere gli archi.
\end{remark}

\begin{theorem}[Cammini e passeggiate]
    \label{cammini e passeggiate}
    Sia $G$ un grafo, e $u, v \in V(G)$ due suoi vertici; allora, in $G$ esiste una passeggiata $u \rightarrow v$, se e solo se esiste un cammino $u \rightarrow v$.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Sia $u \rightarrow v$ una passeggiata da $u$ a $v$; allora, per trovare il cammino $u \rightarrow v$, è sufficiente considerare il sottoinsieme minore, di vertici ed archi, della passeggiata, tale che $u$ e $v$ siano connessi.
        \item[] \textit{Seconda implicazione.} Per definizione, una passeggiata è un qualsiasi percorso tra due vertici di un grafo, e in particolare un cammino è una passeggiata, e dunque il cammino $u \rightarrow v$ è anche un passeggiata.
    \end{itemize}
\end{proof}

\begin{definition}[Ciclo]
    Un \textit{ciclo} è un cammino chiuso.
\end{definition}

\begin{example}[Cicli di un grafo]
    Ad esempio, si consideri questo grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, si hanno tre cicli: $$\{2, (2, 4), 4, (4,3), 3, (3, 2), 2\}$$ $$\{2, (2, 4), 4, (4, 1), 1, (1, 2), 2\}$$ $$\{1, (1, 2), 2, (2, 3), 3, (3, 4), 4, (4, 1), 1\}$$
\end{example}

\begin{definition}[Ordinamento topologico]
    I vertici di un grafo diretto si definiscono \textit{ordinati topologicamente}, se disposti in modo tale che ogni vertice viene prima di tutti i vertici collegati ai suoi archi uscenti.
\end{definition}

\begin{example}[Ordinamento topologico]
    Ad esempio, nel seguente grafo sono presenti vari ordinamenti topologici:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=5] {6};
            \node[main node] (7) [below left of=6] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (4)
                (2) edge (1)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (5)
                (4) edge (7)
                (7) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto con ordinamenti topologici.}
    \end{figure}

    ad esempio, uno di questi è $\{2, 3, 1, 4, 5, 7, 6\}$.
\end{example}

\begin{theorem}[Ordinamento topologico]
    \label{Ordinamento topologico}
    Un grafo diretto $G$ ha un ordinamento topologico se e solo se è aciclico.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Per assurdo, sia $G$ un grafo diretto ciclico, avente dunque almeno un ciclo, con un ordinamento topologico, e siano $\{v_0, \ldots , v_{k - 1}, v_0\}$ i vertici che costituiscono uno dei cicli di $G$; allora, si ha che $v_0 \rightarrow v_1 \rightarrow \ldots \rightarrow v_{k - 1} \rightarrow v_0$, dunque all'interno dell'ordinamento topologico $v_0$ dovrebbe essere posto contemporaneamente prima e dopo $v_1, \ldots, v_{k - 1} \ \lightning$.
        \item[] \textit{Seconda implicazione.} Sia $G$ un grafo aciclico; allora per definizione, all'interno di esso non esistono cicli, ed è dunque possibile enumerare in sequenza ogni vertice $G$, senza creare dipendenze circloari, per poter trovare un ordinamento topologico del grafo.
    \end{itemize}
\end{proof}

\begin{corollary}[Vertici particolari]
    \label{vertici particolari}
    In un grafo diretto aciclico, esiste almeno un vertice senza archi entranti, ed almeno un vertice senza archi uscenti.
\end{corollary}

\begin{proof}
    Per il teorema precedente, è sufficiente considerare un ordinamento topologico del grafo, dove in esso il primo vertice non ha archi entranti, mentre l'ultimo non ha archi uscenti.
\end{proof}

\begin{definition}[Arborescenza]
    Sia $G$ un grafo diretto, e $r$ un suo vertice; $G$ è detto \textit{arborescenza} se e solo se, per ogni vertice $v \in V(G) - \{r\}$, esiste uno ed un solo cammino diretto $r \rightarrow v$; in tal caso, $r$ prende il nome di \textit{radice}.
\end{definition}

\begin{remark}[Arborescenza]
    Sia $G$ un grafo diretto, e $v$ un suo vertice; allora, l'insieme degli archi raggiungibili da $v$ formano l'\textit{arborescenza di $v$} in $G$, e $v$ prende il nome di \textit{radice}. In simboli $$A_v := \{(v', v'') \in E(G) : v \rightarrow (v', v'')\} \subseteq E(G)$$ è l'arborescenza di $v$ in $G$. Si noti che, spesso, il sottografo generato dall'arborescenza di $v$ viene identificato con l'arborescenza stessa.
\end{remark}

\begin{example}[Arborescenza]
    Si consideri il seguente grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (2) {2};
            \node[main node] (4) [below left of=2] {4};
            \node[main node] (1) [above left of=4] {1};
            \node[main node] (5) [below right of=2] {5};
            \node[main node] (3) [above right of=5] {3};
            \node[main node] (6) [below left of=4] {6};
            \node[main node] (7) [below right of=4] {7};
            \node[main node] (8) [below right of=5] {8};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (4)
                (2) edge (4)
                (2) edge (5)
                (3) edge (5)
                (3) edge (8)
                (4) edge (6)
                (4) edge (7)
                (5) edge (7)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    in esso, ad esempio il sottografo dell'arborescenza di $3$ è

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (3) {3};
            \node[main node] (5) [below left of=3] {5};
            \node[main node] (7) [below left of=5] {7};
            \node[main node] (8) [below right of=5] {8};

            \path[every node/.style={font=\sffamily\small}]
                (3) edge (5)
                (3) edge (8)
                (5) edge (7)
                ;
        \end{tikzpicture}
        \caption{Arborescenza di $3$.}
    \end{figure}
\end{example}

\begin{definition}[Grafo connesso]
    Un grafo è detto \textit{connesso} se per ogni $v_1, v_2 \in V(G)$ esiste un cammino che li collega. Nel caso dei grafi diretti, è sufficiente avere $v_1 \rightarrow v_2$, oppure $v_2 \rightarrow v_1$.
\end{definition}

\begin{example}[Grafo non connesso]
    Ad esempio, si consideri questo grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [right of=4] {5};
            \node[main node] (6) [above right of=5] {6};
            \node[main node] (7) [below right of=5] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (5) edge (6)
                (6) edge (7)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo non connesso.}
    \end{figure}

    Poiché non esiste cammino che possa collegare $4$ e $5$, il grafo non è connesso.
\end{example}

\begin{definition}[Albero]
    Un grafo indiretto è detto \textit{albero} se è connesso ed aciclico.
\end{definition}

\begin{example}[Albero]
    Un esempio di albero è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [below right of=4] {5};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un albero.}
    \end{figure}
\end{example}

\begin{definition}[Grafo fortemente connesso]
    Un grafo diretto è detto \textit{fortemente connesso} se per ogni $v_1, v_2 \in V(G)$ esistono due cammini diretti, che li collegano in entrambe i versi; allora, è necessario avere $v_1 \rightarrow v_2$ e $v_2 \rightarrow v_1$. Si noti che ogni grafo indiretto connesso è anche fortemente connesso, poiché gli archi non hanno direzione.
\end{definition}

\begin{example}[Grafo fortemente connesso]
    Un esempio di grafo fortemente connesso è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo fortemente connesso.}
    \end{figure}
\end{example}

\begin{lemma}[Grafi fortemente connessi]
    Sia $G$ un grafo diretto, e $u \in V(G)$ un suo vertice; allora, $G$ è fortemente connesso, se e solo se $\forall v \in V(G) \quad v \rightarrow u$ e $u \rightarrow v$.
\end{lemma}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} L'implicazione è vera per definizione di grafo diretto fortemente connesso.
        \item[] \textit{Seconda implicazione.} Siano $x, y \in V(G)$; allora, per ipotesi, esistono cammini $x \rightarrow u$, $u \rightarrow x$, $y \rightarrow u$ e $u \rightarrow y$; inoltre, per definizione, tali cammini sono anche passeggiate. In particolare, poiché le passeggiate non hanno vincoli di attraversamento di vertici ed archi, allora è possibile utilizzare la proprietà transitiva, e dunque esistono passeggiate $x \rightarrow u \rightarrow y \implies x \rightarrow y$, e $y \rightarrow u \rightarrow x \implies y \rightarrow x$; allora, per il \cref{cammini e passeggiate}, esistono anche dei cammini $x \rightarrow y$ e $y \rightarrow x$. Allora, per definizione, per ogni coppia di vertici esistono due cammini in entrambe le direzioni, e dunque $G$ è fortemente connesso.
    \end{itemize}
\end{proof}

\begin{definition}[Passeggiata euleriana]
    Una passeggiata si dice \textit{euleriana} se attraversa ogni arco del grafo, senza ripercorrerne nessuno.
\end{definition}

\begin{remark}
    Una passeggiata euleriana è una traccia passante per ogni arco del grafo.
\end{remark}

\begin{example}[Passeggiata euleriana]
    Ad esempio, si consideri il seguente grafo indiretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    in esso, l'unica passeggiata euleriana è $$\{1, (1,2), 2, (2,3), 3\}$$
\end{example}

\begin{theorem}
    Dato un grafo $G$, esiste un circuito euleriano su $G$ se e solo se $G$ è connesso, ed ogni grado dei vertici di $G$ è pari.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Sia $G$ un grafo avente un circuito euleriano; per assurdo, sia $v \in V(G) : \deg(v)$ non sia pari. Allora, percorrendo $G$ secondo il circuito euleriano, giungendo a $v$ non si potrebbe più lasciare tale vertice senza riattraversare uno degli archi gia visitati $\lightning$. Inoltre, se $G$ non fosse connesso, il circuito non potrebbe essere euleriano poiché non potrebbe attraversare tutti gli archi di $G$.
        \item[] \textit{Seconda implicazione.} Omessa.
    \end{itemize}
\end{proof}

\begin{definition}[Passeggiata hamiltoniana]
    Una passeggiata si dice \textit{hamiltoniana} se attraversa ogni nodo del grafo, senza ripercorrerne nessuno.
\end{definition}

\begin{remark}
    Una passeggiata hamiltoniana è un cammino.
\end{remark}

\section{Rappresentazione}

\subsection{Matrici di adiacenza}

\begin{definition}[Matrice di adiacenza]
    Sia $G = (V, E)$ un grafo; allora, è possibile rappresentare $G$ attraverso una matrice $M_G \in \textrm{Mat}_{n \times n}(\{0, 1\})$, dove $$\forall m_{i, j} \in M_G \quad m_{i, j} = \left \{ \begin{array}{ll} 1 & i \sim j\\ 0 & i \nsim j \end{array} \right.$$
\end{definition}

\begin{remark}[Spazio di una matrice]
    Lo spazio utilizzato da una matrice di adiacenza è pari a $O(n^2)$, poiché è necessario rappresentare l'adiacenza di ogni vertice con ogni altro.
\end{remark}

\begin{remark}[Aggiornamento di una matrice]
    Per ogni grafo $G$ indiretto, si ha che $M_G$ è simmetrica; di conseguenza, il costo per aggiornare la corrispondente matrice di adiacenza è $2 O(1)= O(2) = O(1)$, poiché per $v_i, v_j \in V(G)$ non coincidenti, sarà necessario aggiornare $M_G[i, j]$ e $M_G[j, i]$.
\end{remark}

\begin{remark}[Eliminazione di un nodo]
    Per eliminare un nodo da un grafo indiretto, sarà necessario eliminare tutti i suoi collegamenti, e dunque il costo risulta essere $O(n)$, rimuovendo interamente la sua riga e la sua colonna.
\end{remark}

\begin{remark}[Controllo di adiacenza]
    Per controllare che $v_i, v_j \in V(G)$ non coincidenti siano adiacenti, sarà sufficiente controllare $M_G[i, j] = M_G[j, i]$, e dunque il costo di un controllo è $O(1)$.
\end{remark}

\subsection{Liste di adiacenza}

\begin{definition}[Liste di adiacenza]
    Sia $G = (V, E)$ un grafo; allora, è possibile rappresentare $G$ attraverso liste di adiacenza, salvando dunque una lista per ogni vertice, contenente i vertici ad esso adiacenti; in simboli $$\forall v \in V(G) \quad v:[\hat{v} \in V(G) - \{v\} \mid \hat{v} \sim v]$$
\end{definition}

\begin{remark}[Spazio delle liste]
    Dato un certo $v \in V(G)$, la lista di adiacenza corrispondente ha lunghezza $\deg(v)$; allora, il numero di elementi nelle liste di adiacenza, per il \cref{Somma dei gradi}, è pari a $\displaystyle O \left(\sum_{v \in V(G)}{\deg(v)}\right) = O\left( 2 |E(G)| \right)=O(2m) = O(m)$. Si noti inoltre che, per un grafo con pochi archi, nonostante si abbiano le liste poco riempite, è comunque necessario salvare i puntatori a tali liste, e dunque è necessario introdurre un $O(n)$ nel costo totale dello spazio, ottenendo allora $O(n) + O(m) = O(n + m)$.
\end{remark}

\begin{remark}[Controllo di adiacenza]
    Per controllare che due nodi $v, v' \in V(G)$ siano adiacenti, è necessario controllare, ad esempio, se $v'$ è contenuto nella lista di $v$, e dunque il costo per tale controllo è $O(\deg(v))$.
    Si noti che, nel caso peggiore, il grafo rappresentato da liste di adiacenza sarà composto da una sola lista per un certo $v \in V(G)$, contenente ogni altro vertice del grafo $\hat{v} \in V(G) - \{v\}$, e la lunghezza della lista di adiacenza di $v$ sarà $n - 1$. Di conseguenza, nel caso peggiore, il costo per controllare se due vertici sono adiacenti è $O(n)$.
\end{remark}

\begin{remark}[Eliminazione di un nodo]
    Per effettuare la rimozione di un nodo da un grafo, è necessario rimuoverlo da ogni lista di adiacenza in cui compare, e nel caso peggiore esso ha archi verso tutti gli altri nodi; allora, il costo di tale operazione è dato dal maggiore tra $n$ ed $m$, e dunque $O(n) + O(m) = O(n + m)$.
\end{remark}

\begin{remark}[Grafo diretto]
    Si noti che per grafi diretti è necessario effettuare una scelta di rappresentazione: all'interno delle liste è possibile salvare i vertici entranti, i vertici uscenti, o entrambi (assegnando due liste ad ogni vertice).
\end{remark}

\begin{example}[Rappresentazione di un grafo]
    Ad esempio, si consideri il seguente grafo $G$:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=4] {6};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (4) edge (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    allora, la sua corrispondente matrice di adiacenza è
    $$M_G = \left( \begin{array}{llllll}
        0 & 0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 1 & 0 & 0 \\
        0 & 1 & 0 & 1 & 0 & 0 \\
        1 & 1 & 1 & 0 & 1 & 1 \\
        0 & 0 & 0 & 1 & 0 & 1 \\
        0 & 0 & 0 & 1 & 1 & 0 \\
    \end{array} \right)$$

    mentre le corrispondenti liste di adiacenza sono $$\left \{ \begin{array}{l} 1: [4] \\ 2: [4, 3] \\ 3: [2, 4] \\ 4: [1, 3, 5, 6] \\ 5: [4, 6] \\ 6: [4, 5] \end{array} \right.$$
\end{example}

\section{DFS (Depth-first Search)}

\subsection{Trovare un ciclo}

\begin{algorithm}[H]
    \caption{
        Dato un grafo indiretto $G$, con ogni vertice avente grado almeno pari a $2$, l'algoritmo restiuisce un ciclo di $G$.\\
        \textbf{Input}: $G$ grafo indiretto, tale che $\forall v \in V(G) \quad \deg(v) \ge 2$.\\
        \textbf{Output}: un ciclo di $G$.
    }

    \begin{algorithmic}[1]
        \Function{findCycle}{$G$}
            \State $v \in V(G)$ \Comment{un vertice qualsiasi di $G$}
            \State $\texttt{visited} := \verb|{|v\verb|}|$ \Comment{conterrà i vertici visitati}
            \State $v' \in V(G) : v \sim v'$
            \While{$v' \notin \texttt{visited}$} \Comment{tempo costante perché \texttt{visited} è un set}
                \State $\texttt{visited.add(}v'\texttt{)}$
                \State $v' := v'' \in V(G) : \left \{ \begin{array}{l}v' \sim v'' \\ v'' \neq \texttt{visited[visited.length()} - 2\texttt{]} \end{array} \right.$
            \EndWhile
            \State \textbf{return} $\texttt{visited[visited.indexOf(}v'\texttt{)} \texttt{:} \texttt{visited.length()]}$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    L'algoritmo inizia scegliendo un qualsiasi vertice di $G$, denotato alla riga $2$ con $v$; successivamente, alla riga $3$ viene inizializzato un insieme \texttt{visited} che contterà tutti i vertici visitati attraverso l'algoritmo; inotre, alla riga $4$ viene scelto un altro vertice $v'$, che sia adiacente al $v$ di partenza.

    All'interno del ciclo \texttt{while}, alla riga $6$ l'algoritmo salva $v'$ all'interno dell'insieme di vertici visitati, mentre alla riga $7$ viene rimpiazzato $v'$, scegliendo un nuovo vertice, adiacente a $v'$, che sia diverso dal penultimo vertice inserito all'interno di \texttt{visited}. Il motivo per cui quest'ultimo controllo è necessario, è che il penultimo vertice inserito sarà il vertice dal quale $v'$ proveniva, di conseguenza si rischierebbe di ripercorrere uno stesso vertice più di una volta, e dunque non si formerebbe un ciclo. Si noti che è necessaria l'ipotesi per cui $G$ abbia ogni vertice di grado almeno pari a $2$, altrimenti non sarebbe possibile trovare un vertice differente dal penultimo di \texttt{visited}. Il ciclo termina nel momento in cui viene scelto un $v'$ già presente all'interno di \texttt{visited}, in quanto, poiché non è possibile ripercorrere i propri passi, l'unica possibilità in cui si è giunti ad un vertice già visitato è se si è concluso un ciclo.
    
    L'algoritmo termina restituendo uno slice dell'insieme, partendo dal primo indice di $v'$ disponibile (si noti che alla fine dell'algoritmo anche l'ultimo elemento di \texttt{visited} sarà $v'$), fino alla fine.

    Si noti che, nella maggior parte dei linguaggi di programmazione, gli insiemi non hanno ordine, dunque non sarebbe possibile restituire uno slice di \texttt{visited}; allora, per semplicità, all'interno dello pseudocodice presentato, si assume si stia utilizzando una struttura dotata di hashing per l'univocità degli elementi, e di ordine per restituirne uno slice, ad esempio un \texttt{IndexSet}).
\end{remark}

\begin{remark}
    Si noti che \texttt{visited} contiene tutti i nodi visitati, dunque restituire interamente l'insieme potrebbe non fornire un ciclo, come nel seguente grafo
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (2) edge (3)
                (2) edge (4)
                (3) edge (4)
                (4) edge (1)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto contenente un ciclo.}
    \end{figure}

    in cui, ad esempio partendo da $v= 4$, l'unico ciclo è $$\{4, (4, 3), 3, (3, 2), 2, (2, 4), 4\}$$ nonostante al termine dell'algoritmo si avrebbe $\texttt{visited}=[1, 4, 3, 2, 4]$, che non costituisce un ciclo.

\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Il costo di questo algoritmo dipende dalla struttura dati utilizzata per rappresentare il grafo in input: nel caso in cui $G$ è rappresentato attraverso una matrice di adiacenza, il costo del ciclo \texttt{while} è pari a $O(n)$, poiché la riga $7$ richiede di trovare un $v'' \in V(G) : v' \sim v''$, il ché potrebbe portare a dover scorrere tutta la riga/colonna di $v''$, dunque nel caso peggiore $O(n)$; differentemente, rappresentando $G$ attraverso liste di adiacenza, basta scegliere il primo vertice contenuto nella lista di $v''$, e se questo dovesse coincidere con il penultimo elemento di \texttt{visited}, sarà sufficiente scegliere il secondo elemento della lista (sicuramente presente per come $G$ è scelto in ipotesi), dunque si ha $O(2) = O(1)$.

    Infine, si noti che il ciclo \texttt{while} ha costo $O(n)$, poiché nel caso peggiore si ha un ciclo che percorre tutto il grafo.

    Allora, attraverso una rappresentazione matriciale, l'algoritmo ha costo $O(n) \cdot O(n) = O(n^2)$, mentre attraverso la rappresentazione con liste di adiacenza, si ha $O(1) \cdot O(n) = O(n)$.
\end{remark}

\subsection{Visita in DFS}

\begin{definition}[DFS]
    Con DFS si indica il criterio di visita di un grafo; in particolare, DFS sta per \textit{Depth-first Search}, dunque la visita del grafo avviene procendendo sempre più in profondità, retrocedendo esclusivamente se non è più possibile avanzare.
\end{definition}

\begin{algorithm}[H]
    \caption{
        Prima versione dell'algoritmo; dato un grafo indiretto $G$, e un suo vertice $v$, l'algoritmo restituisce tutti i vertici, raggiungibili attraverso cammini, partendo da $v$.\\
        \textbf{Input}: $G$ grafo indiretto; $v$ un vertice di $G$.\\
        \textbf{Output}: i vertici raggiungibili da $v$.
    }

    \begin{algorithmic}[1]
        \Function{findReachableNodes$_1$}{$G$, $v$}
            \State $\texttt{visited}:=\texttt{[}0\texttt{]} * n$ \Comment{array di $n$ zeri}
            \State $\texttt{visited[}v\texttt{]} = 1$
            \State $\texttt{Stack S}:=\texttt{[}v\texttt{]}$
            \While{$!\texttt{S.isEmpty()}$}
                \State $v_{top}=\texttt{S.top()}$
                \If{$\exists z \in V(G) : \left \{ \begin{array}{l}z \sim v_{top} \\ \texttt{visited[}z\texttt{]}=0 \end{array} \right.$}
                    \State $\texttt{S.push(}z\texttt{)}$
                    \State $\texttt{visited[}z\texttt{]} = 1$
                \Else
                    \State $\texttt{S.pop()}$
                \EndIf
            \EndWhile
            \State \textbf{return} \texttt{visited}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{proof}
    Per assurdo, sia $\hat v \in V(G)$, raggiungibile da $v$ attraverso un cammino, che non sia stato raggiunto dall'algoritmo; allora, per definizione esiste un cammino $v, e_1, v_1, \ldots, v_{n - 1}, v_n, \hat v$; inoltre, sia $v_i$ il vertice con indice maggiore all'interno del cammino, raggiunto dall'algoritmo, e dunque avendo che $\left \{ \begin{array}{l}v_i \sim v_{i + 1} \\ v_{i + 1} \notin \texttt{visited}  \end{array} \right.$. Allora, per costruzione dell'algoritmo, $v_i$ sarebbe stato rimosso dallo stack, alla riga $11$, prima che $v_{i + 1}$ potesse essere visitato; ma poiché $v_i \sim v_{i +1}$, allora l'algoritmo dovrebbe aver sbagliato esecuzione, poiché $v_{i +1}$ sarebbe stato raggiunto alla riga $7$ inevitabilmente $\lightning$.
\end{proof}

\begin{remark}[Costo dell'algoritmo]
    Si consideri $G$ rappresentato attraverso matrice di adiacenza; allora, il costo della riga $7$, nel caso peggiore, è $O(n)$, poiché è necessario controllare tutta la riga/colonna di $v_{top}$ per trovare un vertice $z$ tale che $\texttt{visited[}z\texttt{]} = 0$, dunque non sia stato ancora visitato. Per ragione analoga, rappresentando $G$ attraverso liste di adiacenza, nel caso peggiore si ha una sola lista corrispondente ad un singolo vertice di $G$, e sarà dunque necessario effettuare $O(n - 1) = O(n)$ controlli.

    Inoltre, si noti che il caso peggiore dell'algoritmo si ha quando $v$ può raggiungere ogni altro nodo di $G$, e dunque il ciclo \texttt{while} sarà ripetuto $O(2n - 1) = O(2n) = O(n)$ volte, poiché ogni vertice verrà inserito e rimosso dallo stack, eccetto il primo, inserito alla riga $4$.

    Allora, il costo complessivo dell'algoritmo, indipendentemente dalla rappresentazione di $G$, è pari a $O(n) \cdot O(n) = O(n^2)$.
\end{remark}

\begin{remark}[Albero]
    \label{Sottografo di un grafo indiretto}
    Sia $G$ un grafo indiretto; considerando l'insieme di archi attraversati dall'algoritmo per trovare ogni vertice raggiungibile partendo da $v$, al termine della procedura si ottiene un sottografo indiretto di $G$ connesso ed aciclico: connesso, poiché l'algoritmo procede per adiacenza di vertici, ed aciclico, poiché l'algoritmo non visita lo stesso vertice più di una volta. Allora, per definizione, tale sottografo è un albero.
\end{remark}

\begin{remark}[Grafo diretto]
    Si noti che l'algoritmo è valido anche per grafi diretti.
\end{remark}

\begin{remark}[Arborescenza]
    Sia $G$ un grafo diretto; considerando l'insieme di archi attraversati dall'algoritmo per trovare ogni vertice raggiungibile partendo da $v$, al termine della procedura si ottiene un sottografo diretto di $G$ connesso ed aciclico, per gli stessi motivi dell'\cref{Sottografo di un grafo indiretto}; tale sottografo è un arborescenza di $v$.
\end{remark}

\begin{algorithm}[H]
    \caption{
        Seconda versione dell'algoritmo; dato un grafo indiretto $G$, rappresentato attraverso liste di adiacenza, e un suo vertice $v$, l'algoritmo restituisce tutti i vertici, raggiungibili attraverso cammini, partendo da $v$.\\
        \textbf{Input}: $G$ grafo indiretto, rappresentato attraverso liste di adiacenza; $v$ un vertice di $G$.\\
        \textbf{Output}: i vertici raggiungibili da $v$.
    }

    \begin{algorithmic}[1]
        \label{findReachableNodes2}
        \Function{findReachableNodes$_2$}{$G$, $v$}
            \State $\texttt{visited} := \verb|{|v\verb|}|$
            \State $\texttt{Stack S} := \texttt{[}v\texttt{]}$
            \While{$!\texttt{S.isEmpty()}$}
                \State $v_{top}=\texttt{S.top()}$
                \While{$!v_{top}\texttt{.adjacent().isEmpty()}$}
                    \State $z := v_{top}\texttt{.adjacent()[}0\texttt{]}$
                    \State $v_{top}\texttt{.adjacent().remove(}0\texttt{)}$ \Comment{fa la differenza}
                    \If{$z \notin \texttt{visited}$}
                        \State $\texttt{visited.add(}z\texttt{)}$
                        \State $\texttt{S.push(}z\texttt{)}$
                        \State \textbf{break}
                    \EndIf
                \EndWhile
                \If{$v_{top}\texttt{ == S.top()}$}
                    \State \texttt{S.pop()}
                \EndIf
            \EndWhile
            \State \textbf{return} \texttt{visited}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    Questa seconda versione dell'algoritmo presenta una miglioria sostanziale alla riga $8$: infatti, attraverso questa riga si rimuovono di volta in volta i vertici adiacenti appena già visitati; di conseguenza, i vertici adiacenti da controllare saranno progressivamente sempre meno. Infatti, si noti che senza la riga $8$, l'algoritmo si comporterebbe come la prima versione.

    Il \texttt{break} alla riga $12$ interrompe il ciclo \texttt{while} della riga $6$, facendo sì che $v_{top}$ della riga $5$, all'iterazione successiva del \texttt{while} della riga $4$, sia pari a $z$, dunque cambiando il vertice correntemente in esame. Di conseguenza, alla riga $15$ il controllo sarà valutato a \texttt{True} esclusivamente se non è mai stata eseguita la riga $11$ per tutta l'iterazione del ciclo \texttt{while} della riga $6$, ovvero quando tutti i vertici adiacenti a $v_{top}$ sono già stati visitati.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    \label{costo findReachableNodes2}
    Poiché i nodi visitati vengono eliminati, il costo del ciclo \texttt{while} dipende da operazioni eseguite in tempo costante $O(1)$, e da quanti nodi vengono controllati per ogni iterazione del ciclo, ma poiché non si possono ricontrollare più volte gli stessi nodi, allora il costo del ciclo dipende solamente dalla dimensione delle liste di adiacenza, e dunque si ha $\displaystyle O\left( \sum_{v \in V(G)}{O(1) + \deg(v)}\right)=O\left(\sum_{v \in V(G)}{O(1)}\right) + O\left(\sum_{v \in V(G)}{\deg(v)}\right) = O(n) + O(m) = O(n+ m)$, per il \cref{Somma dei gradi}.
\end{remark}

\begin{remark}[Grafo diretto]
    Per estendere questo algoritmo a grafi diretti, è necessario fornire in input un grafo rappresentato attraverso liste di adiacenza, le quali devono contenere esclusivamente i vertici uscenti, poichè sono gli unici archi percorribili.
\end{remark}

\subsection{Trovare un ordinamento topologico}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto aciclico $G$, l'algoritmo restituisce un suo ordinamento topologico.\\
        \textbf{Input}: $G$ grafo diretto aciclico.\\
        \textbf{Output}: un ordinamento topologico di $G$.
    }

    \begin{algorithmic}[1]
        \Function{findTopologicalSorting}{$G$}
            \State $\texttt{order} := \texttt{[}\texttt{]}$
            \While{$V(G) \neq 0$}
                \State $v \in V(G) : v.\texttt{incoming\_adjacent().length()} = 0$
                \State $\texttt{order.append(}v\texttt{)}$
                \State $V(G)\texttt{.remove(}v\texttt{)}$
            \EndWhile
            \State \textbf{return} \texttt{order}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    L'algoritmo inizia definendo una lista vuota \texttt{order}, all'interno della quale verrà salvato l'ordinamento topologico; successivamente, alla riga $3$, viene inizializzato un ciclo \texttt{while} che, in ogni iterazione, trova un vertice $v$ il cui numero di vertici adiacenti entranti è $0$, e lo inserisce in \texttt{order}; questo garantisce che ogni vertice inserito venga necessariamente inserito prima di ogni suo arco uscente, e ne esiste sempre almeno uno grazie al \cref{vertici particolari}. Si noti inoltre che, poiché $G$ è aciclico, è garantito che rimuovendo un vertice senza archi entranti, il grafo risultante sarà ancora aciclico, ed è possibile dunque ripetere il ragionamento induttivamente per poter dimostrare la correttezza dell'algoritmo.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Il ciclo \texttt{while} della riga $3$, indipendentemente dalla struttura di rappresentazione del grafo $G$, deve essere eseguito $n$ volte, e dunque ha costo $O(n)$, poiché l'ordinamento topologico deve coinvolgere ogni nodo del grafo, e alla riga $6$ i nodi controllati vengono progressivamente rimossi.

    Rappresentando $G$ attraverso matrice di adiacenza, indicando con $1$ i vertici adiacenti entranti, il costo della riga $4$ è pari a $O(n^2)$, poiché per trovare un vertice $v$ che non abbia archi entranti, è necessario controllare tutta la sua riga/colonna, e dunque nel caso peggiore, per trovarlo sarà necessario controllare l'intera matrice; inoltre, per effettuare la rimozione di $v$ alla riga $6$, il costo è $O(n)$, Allora, il costo complessivo dell'algoritmo risulta essere $O(n) \cdot [O(n^2) + O(n)]= O(n) \cdot O(n^2) = O(n^3)$.

    Differentemente, rappresentando $G$ attraverso liste di adiacenza, salvando solamente i vertici adiacenti entranti per ogni nodo, alla riga $4$ per trovare un nodo senza archi entranti è sufficiente controllare il numero di elementi della lista di ogni vertice, operazione a costo $O(1)$, e dunque il costo, nel caso peggiore, è $O(n - 1) = O(n)$; inoltre, per rimuovere $v$ alla riga $6$, il costo è pari a $O(n + m)$. Allora, il costo complessivo dell'algoritmo risulta essere $O(n) \cdot [O(n) + O(n + m)] = O(n) \cdot [O(2n + m)] = O(n) \cdot O(n + m) = O(n \cdot (n +m))$.
\end{remark}

\section{Tempi di visita e di chiusura}

\subsection{Definizioni}

\begin{definition}[Tempo di visita e di chiusura]
    All'interno degli algoritmi che visitano grafi secondo DFS, è possibile introdurre un \texttt{counter} inizializzato ad $1$, ed incrementato ogni volta che viene attraversato un \textit{nuovo} vertice.

    Allora, per ogni vertice $v$ del grafo diretto in input, si definiscono $t(v)$, detto \textit{tempo di visita di $v$}, pari al valore del \texttt{counter} la prima volta che $v$ viene visitato, e $T(v)$, detto \textit{tempo di chiusura di $v$}, pari al valore del \texttt{counter} nel momento in cui $v$ viene rimosso dallo stack.

    Inoltre, si definisce $\mathrm{Int}(v) := [t(v), T(v)]$.
\end{definition}

\begin{remark}[Intervalli delle foglie]
    Si noti che per ogni foglia $v$ del grafo, ovvero i vertici per i quali non è più possibile scendere di profondità, si ha $t(v) = T(v)$, per definizione stessa dei tempi.
\end{remark}

\begin{lemma}[Proprietà degli intervalli]
    \label{Intervalli diretto}
    Sia $G$ un grafo diretto, e $u, v \in V(G)$ adiacenti; allora solo una delle seguenti proposizioni è vera:
    \begin{enumerate}[i)]
        \item $\mathrm{Int}(u) \subseteq \mathrm{Int}(v)$
        \item $\mathrm{Int}(v) \subseteq \mathrm{Int}(u)$
        \item $\mathrm{Int}(u) \cap \mathrm{Int}(v) = \varnothing$
    \end{enumerate}
    
    Dunque, gli intervalli o sono l'uno interamente contenuto nell'altro, o non si intersecano.
\end{lemma}

\begin{proof}
    La tesi equivale a dimostrare che non può verificarsi il caso in cui c'è intersezione non vuota tra i due intervalli, e dunque non è possibile che $\mathrm{Int}(u) \cap \mathrm{Int}(v) \neq \varnothing$, ovvero $t(u) < t(v) < T(u) < T(v)$, allora:

    \begin{itemize}
        \item $t(u) < t(v) \implies u$ inserito nello stack prima di $v$
        \item $t(v) < T(u) \implies u$ viene rimosso dallo stack dopo aver visitato $v$, ma poiché $u$ era sotto a $v$ all'interno dello stack, necessariamente $v$ deve essere stato rimosso dallo stack prima di $u$, e allora non è possibile che $T(u) < T(v) \ \lightning$.
    \end{itemize}
    
    Si noti che, avendo ad esempio $(u, v) \in E(G)$, e dunque $u$ incidente su $v$, allora necessariamente $\mathrm{Int}(u) \cap \mathrm{Int}(v) \implies t(v) < T(v) < t(u) \le T(u)$.
\end{proof}

\begin{lemma}[Proprietà degli intervalli]
    Sia $G$ un grafo indiretto, e $u, v \in V(G)$ adiacenti; allora si verifica una sola tipologia di inclusione, in cui $\mathrm{Int}(u) \subseteq \mathrm{Int}(v)$, oppure $\mathrm{Int}(v) \subseteq \mathrm{Int}(u)$, e poiché gli archi non sono orientati perde di significato la distinzione tra i due casi.
\end{lemma}

\begin{proof}
    La tesi equivale a dimostrare che non può verificarsi il caso in cui c'è intersezione vuota tra i due intervalli, e dunque non è possibile che $\mathrm{Int}(u) \cap \mathrm{Int}(v) = \varnothing$, ovvero $t(u) \le T(u) < t(v) \le T(v)$, poiché $T(u) < t(v)$ implicherebbe che $u$ verrebbe rimosso dallo stack prima che $v$ possa essere inserito, e questo non è possibile per costruzione della visita DFS, poiché $u \sim v$.
\end{proof}

\subsection{Categorie di archi}

\begin{remark}[Categorie di archi]
    Sia $G= (V, E)$ un grafo diretto, $\hat v \in V(G)$, e sia $A_{\hat v}$ la sua arborescenza; allora, è possibile classificare ogni arco $(u, v) \in E(G) - E(A_{\hat v})$, mediante $\mathrm{Int}(u)$ e $\mathrm{Int}(v)$:
    \begin{itemize}
        \item $\mathrm{Int}(u) \subseteq \mathrm{Int}(v)$, allora l'arco $(u, v)$ è un \textit{backward edge}, ovvero in avanti: sono gli archi che congiungono due nodi dello stesso ramo di $A_{\hat v}$, nel caso in cui $v$ è più in profondità di $u$ nella visita DFS 
        \item $\mathrm{Int}(v) \subseteq \mathrm{Int}(u)$, allora l'arco $(u, v)$ è un \textit{forward edge}, ovvero all'indietro: sono gli archi che congiungono due nodi dello stesso ramo di $A_{\hat v}$, nel caso in cui $u$ è più in profondità di $v$ nella visita DFS
        \item $\mathrm{Int}(v) \cap \mathrm{Int}(u) = \varnothing$, allora l'arco $(u, v)$ è un \textit{cross edge}, detto \textit{arco di attraversamento}: sono gli archi che congiungono due nodi di rami differenti in $A_{\hat v}$
    \end{itemize}
\end{remark}

\begin{remark}[Categorie di archi]
    Sia $G=(V, E)$ un grafo indiretto, $\hat v \in V(G)$, e sia $T_{\hat v}$ il suo albero; allora, ogni arco $(u, v) \in E(G) - E(T_{\hat v})$ viene classificato come \textit{backward edge}.
\end{remark}

\begin{example}
    TODO
\end{example}

\begin{theorem}[Presenza di cicli]
    Sia $G$ un grafo indiretto connesso; allora $G$ ha un ciclo se e solo se in esso esiste un backward edge in ogni albero.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Per assurdo, sia $G$ un grafo indiretto, in cui è presente almeno un ciclo, e non sono presenti backward edge; inoltre, sia $\hat v \in V(G)$, e sia $T_{\hat v}$ il suo albero. Allora, poiché $G$ non ha backward edge, necessariamente gli unici suoi archi sono quelli che compongono $T_{\hat v}$, e dunque $E(G) = E(T_{\hat v}) \implies G = T_{\hat v} \implies G$ è un albero, e dunque $G$ non ha cicli $\lightning$.
        \item[] \textit{Seconda implicazione.} Sia $G$ un grafo indiretto connesso, sia $\hat v \in V(G)$, $T_{\hat v}$ il suo albero, e sia $(u, v) \in E(G) - E(T_{\hat v})$ un backward edge. Allora, poiché $u, v \in V(T_{\hat v})$, è sufficiente considerare il cammino tale che $u \rightarrow v$, che esiste poiché $T_{\hat v}$ è un albero, e dunque $\{u \rightarrow v\} \cup (u, v)$ è un ciclo di $G$.
    \end{itemize}
\end{proof}

\begin{algorithm}[H]
    \caption{
        Dato un grafo $G$, rappresentato attraverso liste di adiacenza (nel caso di $G$ diretto, l'adiacenza è dei nodi uscenti), e un suo vertice $r$, l'algoritmo restituisce i tempi di visita e di chiusura dei nodi di $G$, relativi alla visita dell'albero, o dell'arborescenza, di $r$.\\
        \textbf{Input}: $G$ grafo, rappresentato attraverso liste di adiacenza; $r$ un vertice di $G$.\\
        \textbf{Output}: tempi di visita e di chiusura dei $v \in V(G)$, relativi all'albero, o all'arborescenza, di $r$.
    }

    \begin{algorithmic}[1]
        \Function{DFS}{$G$, $v$, \texttt{visited}, \texttt{c}, \texttt{t}, \texttt{T}}
            \For{$u \in V(G) : (v, u) \in E(G)$} \Comment{$u$ deve essere uscente da $v$}
                \If{$u \notin \texttt{visited}$}
                    \State $\texttt{c.increment()}$
                    \State $\texttt{t[}u\texttt{]}=\texttt{c}$
                    \State $\texttt{visited.add(}u\texttt{)}$
                    \State $\texttt{DFS(}G, u, \texttt{visited}, \texttt{c}, \texttt{t}, \texttt{T)}$
                \EndIf
            \EndFor
            \State $\texttt{T[}v\texttt{]} = \texttt{c}$
        \EndFunction
        \\
        \Function{findTimes}{$G$, $r$}
            \State $\texttt{visited} := \verb|{|r\verb|}|$
            \State $\texttt{t} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{T} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{t[}r\texttt{]}=1$
            \State $\texttt{Counter c} := 1$ \Comment{questo contatore \underline{deve essere un oggetto}}
            \State $\texttt{DFS(}G, r, \texttt{visited}, \texttt{c}, \texttt{t}, \texttt{T)}$
            \State \textbf{return} \texttt{t}, \texttt{T}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    L'algoritmo inizia salvando la radice $r$ all'interno di un insieme \texttt{visited}, ed inizializzando gli array \texttt{t} e \texttt{T} con $0$; inoltre, il tempo di visita di $r$ viene inizializzato a $1$, alla riga $17$; infine, viene istanziato un contatore, partendo da $1$ (poiché la radice è già stata inizializzata).

    All'interno della funzione ricorsiva, per ogni livello della ricorsione, viene esplorato ogni vertice adiacente a $v$ in ingresso; in particolare, se gia non visitato, viene scelto un $u$ tale che $u \sim v$. Successivamente, viene aggiornato il contatore, e viene salvato il tempo di visita di $u$; infine, viene aggiunto il vertice a \texttt{visited}. Alla riga $7$, la funzione ricorsiva viene eseguita nuovamente, utilizzando come nuovo nodo di partenza $u$. Infine, per ogni livello di ricorsione, dopo aver terminato i vertici adiacenti, il ciclo \texttt{for} della riga $2$ termina, e alla riga $10$ viene aggiornato il tempo di chiusura del vertice $v$.

    Allora, il codice è in grado di visitare il grafo intermaente, senza ripercorrere vertici già visitati, utilizzando una visita in DFS, poiché vengono esplorati tutti i vertici adiacenti ricorsivamente, prima di tornare al vertice precedente.

    Si noti che l'algoritmo funziona correttamente, solamente se \texttt{c} è un oggetto e non una variabile; infatti, il contatore si deve comportare come se fosse globale per ogni livello di ricorsione, altrimenti i tempi sarebbero tutti errati; in particolare, senza trattare il contatore come oggetto, il contatore, ritornando indietro con i livelli ricorsivi, decrementerebbe.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Si noti che l'algoritmo controlla ogni singolo vertice una ed una sola volta, e la vista avviene in DFS; inoltre, poiché si ha un ciclo \texttt{for} all'interno di ogni livello della ricorsione, per costruzione stessa, l'algoritmo si comporta esattamente come l'\cref{findReachableNodes2}. Allora, poiché il grafo è rappresentato tramite liste di adiacenza, per ragionamento analogo all'\cref{costo findReachableNodes2}, il costo dell'algoritmo è pari a $O(n + m)$.
\end{remark}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto $G$, rappresentato attraverso liste di adiacenza (per ogni vertice sono salvate due liste, dei vertici entranti e dei vertici uscenti), e un suo vertice $v$, l'algoritmo restituisce gli archi non facenti parti dell'arborescenza di $v$, categorizzati in base ai loro intervalli di apertura e chiusura.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso liste di adiacenza; $v$ un vertice di $G$.\\
        \textbf{Output}: archi non dell'arborescenza, categorizzati per intervalli.
    }

    \begin{algorithmic}[1]
        \Function{categorizeEdges}{$G$, $v$}
            \State $\texttt{visited} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{visited[}v\texttt{]}=1$
            \State $\texttt{Stack S}:=\texttt{[}v\texttt{]}$
            \State $\texttt{c}:=1$
            \State $\texttt{t} := \texttt{[}0\texttt{]} * n$ \Comment{tempi di visita}
            \State $\texttt{T} := \texttt{[}0\texttt{]} * n$ \Comment{tempi di chiusura}
            \State $\texttt{t[}v\texttt{]}=\texttt{c}$
            \State $\texttt{parents} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{parents[}v\texttt{]}=v$ \Comment{per riconoscere la radice}
            \While{$!\texttt{S.isEmpty()}$}
                \State $v_{top} := \texttt{S.top()}$
                \While{$!v_{top}\texttt{.outgoing\_adjacent().isEmpty()}$}
                    \State $z:=v_{top}\texttt{.outgoing\_adjacent()[}0\texttt{]}$
                    \State $v_{top}\texttt{.outgoing\_adjacent().remove(}0\texttt{)}$
                    \If{$\texttt{visited[}z\texttt{]}==0$}
                        \State $\texttt{visited[}z\texttt{]}=1$
                        \State $\texttt{S.push(}z\texttt{)}$
                        \State $\texttt{parents[}z\texttt{]}=v_{top}$
                        \State $\texttt{c += } 1$
                        \State $\texttt{t[}z\texttt{]}=\texttt{c}$
                        \State \textbf{break}
                    \EndIf
                \EndWhile
                \If{$v_{top}\texttt{ == S.top()}$}
                    \State \texttt{S.pop()}
                    \State $\texttt{T[}v_{top}\texttt{]}=\texttt{c}$
                \EndIf
            \EndWhile
            \algstore{bkbreak}
    \end{algorithmic}
\end{algorithm}

\begin{nocaptionalg}
    \begin{algorithmic}[1]
            \algrestore{bkbreak}
            \State $\texttt{forward} := \texttt{[]}$
            \State $\texttt{backward} := \texttt{[]}$
            \State $\texttt{cross} := \texttt{[]}$

            \For{$v \in V(G)$}
                \For{$u \in v\texttt{.incoming\_adjacent()}$}
                    \If{$\texttt{parents[}v\texttt{]}==u$}
                        \State \textbf{continue} \Comment{faceva parte dell'arborescenza di $v$}
                    \ElsIf{$\texttt{T[}u\texttt{]} < \texttt{t[}v\texttt{]} \ \texttt{or} \ \texttt{T[}v\texttt{]} < \texttt{t[}u\texttt{]}$}
                        \State $\texttt{cross.append(}(u, v)\texttt{)}$
                    \ElsIf{$\texttt{T[}u\texttt{]} \le \texttt{T[}v\texttt{]}$}
                        \State $\texttt{backward.append(}(u, v)\texttt{)}$
                    \Else
                        \State $\texttt{forward.append(}(u, v)\texttt{)}$
                    \EndIf
                \EndFor
            \EndFor

            \State \textbf{return} \texttt{forward}, \texttt{backward}, \texttt{cross}
        \EndFunction
    \end{algorithmic}
\end{nocaptionalg}

\begin{remark}[Correttezza dell'algoritmo]
    TODO
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Si noti che il ciclo \texttt{while} che inizia alla riga $11$, e termina alla riga $29$, ha lo stesso costo computazionale dell'\cref{findReachableNodes2}, e dunque il suo costo è pari a $O(n + m)$.

    Si noti inoltre che, il ciclo \texttt{for} della riga $33$, effettua un'iterazione per ogni singolo vertice del grafo, ma all'interno di esso è presente un ulteriore ciclo \texttt{for}, alla riga $34$, che itera sui rispettivi vertici adiacenti entranti; allora, il costo di questi due cicli equivale al solo spazio di rappresentazione delle liste di adiacenza di $G$, ovvero $O(n + m)$, poiché al loro interno vengono eseguite esclusivamente operazioni in tempo costante.

    In conclusione, il costo computazionale è pari a $O(n + m) + O(n + m) = O(n + m)$.
\end{remark}

\begin{algorithm}[H]
    \caption{
        Dato un'array di padri \texttt{parents}, che rappresenta un'arborescenza di visita in DFS di un grafo diretto, e un arco $(x, y)$ del grafo, l'algoritmo restituisce il tipo di arco.\\
        \textbf{Input}: \texttt{parents} array di padri di un'arborescenza di visita in DFS di un grafo diretto; $(x, y)$ un arco del grafo.\\
        \textbf{Output}: la categoria di $(x, y)$.
    }

    \begin{algorithmic}[1]
        \Function{categorizeEdge}{\texttt{parents}, $(x, y)$}
            \If{$\texttt{parents[}y\texttt{]}==x$}
                \State \textbf{return} \texttt{NodeType::Arborescence}
            \EndIf
            \State $z := y$
            \While{$\texttt{parents[}z\texttt{]} \neq z$}
                \State $z = \texttt{parents[}z\texttt{]}$
                \If{$z == x$}
                    \State \textbf{return} \texttt{NodeType::Forward}
                \EndIf
            \EndWhile
            \While{$\texttt{parents[}z\texttt{]} \neq z$}
                \State $z = \texttt{parents[}z\texttt{]}$
                \If{$z == y$}
                    \State \textbf{return} \texttt{NodeType::Backward}
                \EndIf
            \EndWhile
            \State \textbf{return} \texttt{NodeType::Cross}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    TODO
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    TODO O(n)
\end{remark}

\subsection{Trovare un ordinamento topologico}

\begin{theorem}[Presenza di cicli]
    \label{Cicli diretto}
    Sia $G$ un grafo diretto connesso; allora $G$ ha un ciclo se e solo se in esso esiste un backward edge in almeno un'arborescenza.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} TODO
        \item[] \textit{Seconda implicazione.} Sia $G$ un grafo diretto fortemente connesso, e sia $\hat v \in V(G)$ tale che la sua arborescenza $A_{\hat v}$ contenga un backward edge $(u, v) \in E(G) - E(A_{\hat v})$. Allora, poiché $u, v \in V(A_{\hat v})$, e $(u, v)$ è un backward edge, è sufficiente considerare il cammino tale che $u \rightarrow v$, che esiste poiché $A_{\hat v}$ è un arborescenza, e dunque $\{u \rightarrow v\} \cup (u, v)$ è un ciclo di $G$. Si noti che il fatto che $G$ sia fortemente connesso garantisce di poter considerare un $\hat v \in V(G)$ qualsiasi.
    \end{itemize}
\end{proof}

\begin{corollary}
    Sia $G$ un grafo diretto aciclico connesso, sia $\hat v \in V(G)$ un suo vertice, sia $A_{\hat v}$ la relativa arborescenza, e sia $(u, v) \in E(G)$ un arco; allora $t(v) \le T(u)$.
\end{corollary}

\begin{proof}
    Si noti che ogni arco $(u, v) \in A_{\hat v}$ è un forward edge per costruzione della visita DFS; allora si consideri il caso in cui $(u, v) \in E(G) - A_{\hat v}$. Allora per il teorema precedente, $(u, v)$ non è un backward edge, e dunque per il \cref{Intervalli diretto} si può verificare solo una delle seguenti:
    \begin{itemize}
        \item $\mathrm{Int}(v) \subseteq \mathrm{Int}(u) \implies t(u) < t(v) \le T(v) < T(u)$, e in particolare $t(v) \le T(u)$
        \item $\mathrm{Int}(u) \cap \mathrm{Int}(v) = \varnothing \implies t(v) < T(v) < t(u) < T(u)$, e in particolare $t(v) \le T(u)$.
    \end{itemize}
\end{proof}

\begin{corollary}
    Sia $G$ un grafo diretto aciclico connesso, sia $\hat v \in V(G)$ un suo vertice, sia $A_{\hat v}$ la relativa arborescenza, e sia $(u, v) \in E(G)$ un arco; allora $T(v) \le T(u)$.
\end{corollary}

\begin{proof}
    Per il corollario precedente, per ogni arco di un grafo indiretto aciclico connesso $t(v) \le T(u)$, allora:
    \begin{itemize}
        \item $t(v) < t(u)$: se $T(u) \le T(v)$, allora $(u, v)$ sarebbe un backward edge, che non è possibile avere per il \cref{Cicli diretto}; allora necessariamente $T(v) < T(u)$; ma se $t(u) < T(v)$ allora si avrebbe intersezione non vuota tra gli intervalli, impossibile per il \cref{Intervalli diretto}; allora necessariamente $t(v) < T(v) < t(u) < T(u)$, e dunque $(u, v)$ è un cross edge
        \item $t(u) < t(v)$: se $T(u) < T(v)$, allora gli intervalli avrebbero intersezione non vuota, e ciò non si può verificare per il \cref{Intervalli diretto}; allora necessariamente $t(u) < t(v) \le T(v) \le T(u)$, e dunque $(u, v)$ è un forward edge.
    \end{itemize}

    In particolare, si ha che $T(v) \le T(u)$ in entrambe i casi.
\end{proof}

\begin{theorem}[Ordinamento topologico attraverso i tempi]
    Sia $G$ un grafo diretto aciclico connesso, sia $\hat v \in V(G)$ un suo vertice, e sia $A_{\hat v}$ la sua arborescenza; allora, ordinando i vertici attraverso i loro tempi di chiusura $T$ in ordine decrescente, si ottiene un ordinamento topologico del grafo.
\end{theorem}

\begin{proof}
    Per definizione, un'ordinamento è detto topologico se ogni vertice è posto prima dei suoi archi uscenti; inoltre, per il corollario precedente, per ogni $(u, v) \in E(G)$ si ha $T(v) \le T(u)$, e dunque se si ordinassero i vertici di $G$ utilizzando i tempi di chiusura $T$, in ordine crescente, come criterio, allora $v$ verrebbe prima di $u$, e $(u, v)$ è un arco diretto in cui $u$ è incidente su $v$; allora, segue che ordinando i vertici in ordine decrescente di $T$, si ha un ordinamento topologico di $G$.
\end{proof}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto aciclico connesso $G$, rappresentato attraverso liste di adiacenza in cui vengono salvati gli archi adiacenti uscenti, l'algoritmo restituisce un ordinamento topologico di $G$.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso liste di adiacenza.\\
        \textbf{Output}: un ordinamento topologico di $G$.
    }

    \begin{algorithmic}[1]
        \Function{DFS}{$G$, $v$, \texttt{visited}, \texttt{order}}
            \State $\texttt{visited.add(}v\texttt{)}$
            \For{$u \in V(G) : (v, u) \in E(G)$} \Comment{$u$ deve essere uscente da $v$}
                \If{$u \notin \texttt{visited}$}
                    \State $\texttt{DFS(}G, u, \texttt{visited},\texttt{order)}$
                \EndIf
            \EndFor
            \State $\texttt{order.append(}v\texttt{)}$ \Comment{l'ordinamento risulterà invertito}
        \EndFunction
        \\
        \Function{findTopologicalSortingDFS}{$G$}
            \State $\texttt{order} := \texttt{[]}$
            \State $\texttt{visited} := \verb|{|\verb|}|$
            \For{$v \in V(G)$}
                \If{$v \notin \texttt{visited}$}
                    \State $\texttt{DFS(}G, v, \texttt{visited},\texttt{order)}$
                \EndIf
            \EndFor
            \State $\texttt{order.reverse()}$ \Comment{viene invertita la lista}
            \State \textbf{return} \texttt{order}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    Si noti che l'algoritmo non salva i tempi di chiusura dei vari vertici per ordinarli, ma non è necessario grazie alla ricorsione: infatti, inserendo il vertice alla riga $8$, dunque dopo il loop \texttt{for}, l'inserimento avviene in post-order rispetto alla visita del grafo, e dunque è equivalente a rispettare l'ordinamento crescente dei tempi di chiusura di ogni nodo. Dunque, è sufficiente invertire la lista ottenuta, alla riga $19$, per ottenere un ordinamento topologico.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Si noti che l'algoritmo ha costo $O(n + m)$, poiché attua una sola visita in DFS del grafo, rappresentato attraverso liste di adiacenza, ricorsivamente.
\end{remark}

\subsection{Trovare un pozzo universale}

\begin{definition}[Pozzo universale]
    Sia $G$ un grafo diretto; $v \in V(G)$ è detto \textit{pozzo universale} se ha $n - 1$ archi entranti, e nessun arco uscente.
\end{definition}

\begin{example}[Pozzo universale]
    Ad esempio, il seguente grafo diretto presenta un pozzo universale in $3$:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [above right of=3] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (4) edge (3)
                (4) edge (1)
                (1) edge (3)
                ;
        \end{tikzpicture}
        \caption{Un grafo con pozzo universale in $3$.}
    \end{figure}
\end{example}

\begin{theorem}[Unicità del pozzo universale]
    Sia $G$ un grafo diretto, e $p \in V(G)$ un suo pozzo universale; allora, tale pozzo universale $p$ è unico in $G$.
\end{theorem}

\begin{proof}
    Per assurdo, sia $p' \in V(G)$ un secondo pozzo universale in $G$; allora, per definizione, sia $p$ che $p'$ avrebbero $n - 1$ archi entranti, e nessun arco uscente, ma questo non è possibile poiché l'unico modo per avere entrambe le condizioni verificate sarebbe attraverso un arco bidirezionale tra $p$ e $p' \ \lightning$.
\end{proof}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto $G$, rappresentato attraverso matrice di adiacenza, l'algoritmo restituisce, se presente, il pozzo universale di $G$.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso matrice di adiacenza.\\
        \textbf{Output}: il pozzo universale di $G$, se presente.
    }

    \begin{algorithmic}[1]
        \Function{findUniversalSink}{$M_G$}
            \State $p \in V(G)$ \Comment{un vertice qualsiasi, possibile pozzo universale}
            \For{$v \in V(G)$}
                \If{$M_G[p, v] = = 1$}
                    \State $p = v$
                \EndIf
            \EndFor
            \For{$v \in V(G) - \{p\}$}
                \If{$M_G[p, v] == 1$}
                    \State \textbf{return} \texttt{None}
                \EndIf
                \If{$M_G[v, p] == 0$}
                    \State \textbf{return} \texttt{None}
                \EndIf
            \EndFor
            \State \textbf{return} $p$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    Per definizione stessa di pozzo universale, indipendentemente dalla scelta del vertice di partenza del grafo in input, percorrendo una qualsiasi sequenza di archi, inevitabilmente, si deve giungere al pozzo universale, poiché esso ha esattamente $n - 1$ archi entranti. Allora, alla riga $2$ viene arbitrariamente scelto un possibile pozzo universale, e il ciclo \texttt{for} della riga $3$ percorre la catena di archi possibili, e ha costo $O(n)$. Si noti però che il vertice a cui si è giunti potrebbe non essere un pozzo universale, ad esempio si consideri questo grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (4)
                (2) edge (1)
                (2) edge (4)
                (3) edge (2)
                ;
        \end{tikzpicture}
        \caption{Un grafo che contiene un possibile pozzo universale.}
    \end{figure}

    si noti che ndipendentemente dalla scelta iniziale di $p \in V(G)$, al termine del ciclo \texttt{for} si avrà $p = 4$, pur non essendo $4$ un pozzo universale, poiché $(3, 4) \notin E(G)$. Risulta dunque necessario accertarsi che $p$ sia realmente un pozzo universale, andando dunque a controllare, all'interno del ciclo \texttt{for} della riga $8$, se $p$ non ha archi uscenti, ed ogni altro arco è incidente su $p$. Tali controlli vengono effettuati rispettivamente alla riga $9$, in cui il ciclo termina restituendo \texttt{None} se esiste un vertice uscente da $p$, e alla riga $12$, in cui il ciclo termina analogamente se esiste un vertice non adiacente entrante a $p$.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Poiché i due cicli \texttt{for} percorrono ogni vertice di $G$, una ed una sola volta, il costo dell'algoritmo è pari a $O(n) + O(n) = O(n)$.
\end{remark}

\subsection{Trovare i ponti}

\begin{definition}[Ponte]
    Sia $G$ un grafo, e sia $(u, v) \in E(G)$ un suo arco; allora, $(u, v)$ è detto \textit{ponte} se e solo se non è contenuto in nessun ciclo di $G$.
\end{definition}

\begin{example}[Ponte]
    Un esempio di grafo che presenta un ponte è il seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [right of=4] {5};
            \node[main node] (6) [above right of=5] {6};
            \node[main node] (7) [below right of=5] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (4)
                (4) edge (1)
                (4) edge (5)
                (5) edge (6)
                (6) edge (7)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo con un ponte.}
    \end{figure}

    Infatti, $(4, 5)$ è un ponte poiché gli unici due cicli di $G$ sono $$\{1, (1, 2), 2, (2, 3), 3, (3, 4), 4, (4, 1), 1\}$$ $$\{5, (5, 6), 6, (6, 7), 7, (7, 5), 5\}$$
\end{example}

\begin{theorem}[Presenza di ponti]
    \label{teorema dei ponti}
    Sia $G$ un grafo indiretto connesso, $r \in V(G)$, e sia $T_r$ l'albero di visita in DFS di $r$ in $G$; sia $x \in V(T_r)$, e sia $T_x \subseteq T_r$ il suo sottoalbero in $T_r$; sia inoltre $y \in V(T_x)$ tale che $(x, y) \in E(G)$, e sia $T_y \subseteq T_x$ il suo sottoalbero in $T_x$; allora, esiste un arco $(u, v) \in E(G)$, tale che $u \in V(T_y)$ e $v \in V(T - T_x)$, se e solo se esiste un ciclo in $G$ contenente $(x, y)$.
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{itemize}
        \item[] \textit{Prima implicazione.} Si noti che, poiché $G$ è indiretto e connesso, per qualsiasi $r \in V(G)$, $V(T_r) = V(G)$, dunque la visita in DFS è sempre in grado di raggiungere ogni nodo del grafo $G$.
            Per definizione $T_y$ è connesso ed aciclico, e dunque esiste uno ed un solo cammino $y \rightarrow u$; inoltre, per ragionamento analogo, esiste uno ed un solo cammino $v \rightarrow x$. Allora, se esiste un arco $(u, v) \in E(G)$, viene creato un ciclo in $G$ della forma $v \rightarrow x \rightarrow y \rightarrow u \rightarrow v$, poiché esiste l'arco $(x, y) \in E(G)$ in ipotesi, che sarà dunque necessariamente contenuto in tale ciclo.
        \item[] \textit{Seconda implicazione.}  Se $(x, y)$ è incluso in almeno un ciclo di $G$, deve necessariamente esistere un cammino $x \rightarrow y$ non passante per $(x, y)$, il quale deve contenere un arco $(u, v)$, in cui $u \in V(T_y)$, e $v \in V(T - T_x)$, poiché $(x, y) \in E(G)$ è un arco.

    \end{itemize}
\end{proof}

\begin{lemma}[Alberi con ponti]
    Sia $G$ un grafo indiretto, e $(u, v) \in E(G)$ un suo ponte; allora, per ogni possibile $T_u$, albero di visita di $G$ in DFS, radicato in $u$, si ha che $(u, v) \in E(T_u)$.
\end{lemma}

\begin{proof}
    Poiché $(u, v)$ è un ponte, per definizione non appartiente a nessun ciclo di $G$, allora preso un qualsiasi $T_u$, albero di visita di $G$ in DFS, radicato in $u$, l'unico modo per raggiungere $v$ è attraverso $(u, v)$ stesso, in quanto $G$ è indiretto, e dunque necessariamente $(u, v) \in E(T_u)$
\end{proof}

\begin{algorithm}[H]
    \caption{
        Dato un grafo indiretto $G$, rappresentato attraverso liste di adiacenza, l'algoritmo restituisce i ponti di $G$.\\
        \textbf{Input}: $G$ grafo indiretto, rappresentato attraverso liste di adiacenza.\\
        \textbf{Output}: i ponti di $G$.
    }

    \begin{algorithmic}[1]
        \Function{DFS}{$G$, $y$, \texttt{c}, \texttt{back}, \texttt{t}, \texttt{parents}}
            \State $\texttt{c.increment()}$
            \State $\texttt{t[}y\texttt{]}= \texttt{c}$
            \State $\texttt{back[}y\texttt{]}= \texttt{t[}y\texttt{]}$
            \For{$z \in V(G) : z \sim y$}
                \If{$\texttt{t[}z\texttt{]}==0$} \Comment{$z$ non deve essere già stato visitato}
                    \State $\texttt{parents[}z\texttt{]}=y$
                    \State $\texttt{DFS(}G, z, \texttt{c}, \texttt{back}, \texttt{t}, \texttt{parents)}$
                    \If{$\texttt{back[}z\texttt{]} < \texttt{back[}y\texttt{]}$}
                        \State $\texttt{back[}y\texttt{]} = \texttt{back[}z\texttt{]}$
                    \EndIf
                \ElsIf{$\left \{ \begin{array}{l} z \neq \texttt{parents[}y\texttt{]} \\ \texttt{t[}z\texttt{]} < \texttt{back[}y\texttt{]} \end{array}\right.$}
                    \State $\texttt{back[}y\texttt{]} = \texttt{back[}z\texttt{]}$
                \EndIf
            \EndFor
        \EndFunction
        \\
        \Function{findBridges}{$G$}
            \State $v \in V(G)$ \Comment{un vertice qualsiasi di $G$}
            \State $\texttt{t} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{parents} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{parents[}v\texttt{]}=v$
            \State $\texttt{back} := \texttt{[}0\texttt{]} * n$
            \State $\texttt{Counter c} := 0$ \Comment{è un oggetto}
            \State $\texttt{DFS(}G, v, \texttt{c}, \texttt{back}, \texttt{t}, \texttt{parents)}$
            \State $\texttt{bridges} := \verb|{|\verb|}|$
            \For{$u \in V(G)$}
                \If{$\left \{ \begin{array}{l}\texttt{back[}u\texttt{]}= \texttt{t[}u\texttt{]} \\ u \neq \texttt{parents[}u\texttt{]} \end{array} \right.$}
                    \State $\texttt{bridges.add(}(\texttt{parents[}u\texttt{]}, u)\texttt{)}$
                \EndIf
            \EndFor
            \State \textbf{return} \texttt{bridges}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    TODO da finire

    L'algoritmo inizia scegliendo un vertice $v$ casuale, del grafo $G$ in input; successivamente, vengono definiti gli array \texttt{t}, all'interno del quale verranno salvati i tempi di visita dei vertici, \texttt{parents}, utilizzato per salvare i nodi padri di ogni vertice visitato, e \texttt{back}

    Sia $T$ l'albero di visita in DFS della visita correntemente in esecuzione dall'algoritmo; allora, per un certo vertice $y \in V(T)$, all'interno di \texttt{back[}y\texttt{]}, verrà salvato il tempo di visita del vertice $v \in V(T - T_y)$ più lontano, raggiungibile da un discendente $z$ di $y$ (incluso $y$ stesso), attraverso un cammino passante per un arco $(z, v) \notin E(T)$. L'array \texttt{back} verrà sfruttato congiuntamente al \cref{teorema dei ponti}, in quanto l'arco $(\texttt{parents[}y\texttt{]}, y)$ è un ponte, se e solo se non esiste un tale arco $(z, v)$. TODO FORSE È DA CORREGGERE LA DEF

    Infine, prima di iniziare una visita in DFS ricorsiva dell'albero, viene istanziato un oggetto contatore \texttt{c}, utilizzato per salvare i tempi di visita in \texttt{c}.

    L'esecuzione procede all'interno della funzione ricorsiva \texttt{DFS}, che ha lo scopo di popolare i valori degli array precedentemente definiti. La funzione inizia aggiornando il contatore, e inserendo il relativo valore del tempo di visita del vertice corrente; inoltre, di quest'ultimo viene inizializzato il valore corrisopndente in \texttt{back}, pari al suo stesso tempo di visita. Tale valore servirà come \textit{sentinel value}, e verrà utilizzato successivamente dall'algoritmo per stabilire quali archi del grafo sono ponti.

    Successivamente, viene istanziato un ciclo \texttt{for}, alla riga $5$, per ogni vertice $z$, adiacente al vertice $y$ corrente
    \begin{itemize}
        \item se tale vertice ha tempo di visita pari a $0$, e dunque non è ancora stato visitato, viene inizialmente aggiornato il valore del padre, alla riga $7$, che sarà proprio $y$, e viene poi effettuata una chiamata ricorsiva, radicata in $z$; al termine di quest'ultima, viene aggiornato il valore di $\texttt{back[}y\texttt{]} = \min(\texttt{back[}y\texttt{]}, \texttt{back[}z\texttt{]})$, e dunque sarà sempre il minore tra i suoi discendenti;
        \item se invece è già stato visitato, va aggiornato il valore di $\texttt{back[}y\texttt{]} = \min(\texttt{t[}z\texttt{]}, \texttt{back[}y\texttt{]})$, esclusivamente se $z$ non è il padre di $y$.
    \end{itemize}

    Al termine della visita in DFS ricorsiva, l'algoritmo conclude cercando tutti i ponti del grafo, a partire dalle informazioni all'interno di \texttt{back}: infatti, alla riga $27$, per ogni vertice $u \in V(G)$ del grafo, viene inserito l'arco tra $u$ e il suo vertice padre, se e solo se $u \neq \texttt{parents[}u\texttt{]}$ (ovvero, $u$ non è la radice), e $\texttt{back[}u\texttt{]} = \texttt{t[}u\texttt{]}$, e dunque il valore di $\texttt{back[}y\texttt{]}$ è rimasto invariato dalla riga $4$.

    Ad esempio, si consideri il seguente grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [above right of=1] {2};
            \node[main node] (3) [right of=1] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [left of=1] {5};
            \node[main node] (6) [left of=5] {6};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (1) edge (3)
                (1) edge (4)
                (1) edge (5)
                (4) edge[bend left] (6)
                (5) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    inoltre, sia $$T_6 = (\{6, 5, 1, 2, 3, 4\}, \{(6, 5), (5, 1), (1, 2), (1, 3), (1, 5)\})$$ l'albero di visita in DFS del grafo, partendo dal vertice $6$; allora, si avranno $$\texttt{t} = \texttt{[}3, 4, 5, 6, 2, 1\texttt{]}$$ $$\texttt{back} = \texttt{[}6, 2, 3, 6, 6, 6\texttt{]}$$

    Allora, si consideri $T_1 \subseteq T_6$ il sottoalbero di $T_6$, radicato in $1$, il cui vertice padre è $5$; poiché TODO da finire
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    Il costo dell'algoritmo è $O(n + m)$, poiché è costituito semplicemente da una visita in DFS ricorsiva del grafo in input, e da un ciclo \texttt{for}, alla riga $27$, su tutti i nodi del grafo, e dunque si ha $O(n + m) + O(n) = O(n + m)$.
\end{remark}

\subsection{Trovare le componenti}

\begin{definition}[Componenti indirette]
    Sia $G$ un grafo indiretto, non necessariamente connesso; si definisce \textit{componente} un sottografo di $G$, connesso, non ulteriormente estendibile. Più rigorosamente, sia $H \subseteq G$ un sottografo di $G$; esso è una componente di $G$, se e solo se non esiste $H' \subseteq G$, sottografo connesso di $G$, tale che $H \subsetneq H'$. Le componenti sono anche definite come sottografi \textit{massimalmente connessi}.

    In simboli, dato un vertice $v \in V(G)$, $\mathrm{comp}(v)$ è la componente contenente $v$.
\end{definition}

\begin{example}[Componenti indirette]
    Ad esempio, si consideri questo grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [right of=4] {5};
            \node[main node] (6) [above right of=5] {6};
            \node[main node] (7) [below right of=5] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (2)
                (2) edge (3)
                (3) edge (4)
                (4) edge (1)
                (5) edge (6)
                (6) edge (7)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Un grafo indiretto.}
    \end{figure}

    esso, presenta $2$ componenti: $$H_1 := (\{1, 2, 3, 4\}, \{(1, 2), (2, 3), (3, 4), (4, 1)\})$$ $$H_2 := (\{5, 6, 7\}, \{(5, 6), (6, 7), (7, 5)\})$$
\end{example}

\begin{definition}[Componenti dirette]
    Sia $G$ un grafo diretto, non necessariamente connesso; allora, si definisce \textit{componente} un sottografo di $G$, fortemente e massimalmente connesso.
\end{definition}

\begin{example}[Componenti dirette]
    Ad esempio, si consideri questo grafo:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [above right of=4] {5};
            \node[main node] (6) [below right of=5] {6};
            \node[main node] (7) [above right of=6] {7};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (3)
                (1) edge (5)
                (2) edge (1)
                (3) edge (2)
                (3) edge (4)
                (4) edge (5)
                (4) edge (6)
                (5) edge (7)
                (6) edge (3)
                (6) edge (5)
                (6) edge (7)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    esso, presenta $3$ componenti: $$H_1 := (\{1, 2, 3, 4, 6\}, \{(1, 3), (3, 4), (4, 6), (6, 3), (3, 2), (2, 1)\})$$ $$H_2 := (\{5\}, \varnothing)$$ $$H_3 := (\{7\}, \varnothing)$$
\end{example}

\begin{lemma}[Digiunzione delle componenti]
    \label{disjoint comps}
    Sia $G$ un grafo; allora, le sue componenti sono disgiunte.
\end{lemma}

\begin{proof}
    Per assurdo, sia $G$ un grafo, diretto o indiretto, e $H_1, H_2 \subseteq G$ due sue componenti tali che $H_1 \cap H_2 \neq \varnothing$; se tali componenti esistessero, allora esisterebbe almeno un vertice nella loro intersezione, raggiungibile da entrambe le componenti (nel caso di $G$ diretto, i cammini sarebbero in entrambe le direzioni, poiché tale vertice sarebbe parte sia di $H_1$ che di $H_2$, entrambe fortemente connesse per definizione); allora, $H_1$ e $H_2$ non sarebbero massimalmente connesse $\lightning$.
\end{proof}

\begin{definition}[Contrazione]
    Sia $G$ un grafo, e $H \subseteq G$ un suo sottografo; si definisce \textit{contrazione di $H$ in $G$}, l'operazione che rimuove vertici (ed archi) di $H$ da $G$, e al suo posto inserisce un vertice, generalmente denotato con $v_H$, che viene connesso con $G - H$ dagli archi che precedentemente connettevano $H$ con $G$. In simboli, il grafo $G$, contratto su $H$, verrà indicato con $\mathrm{contr}(G, H)$.
\end{definition}

\begin{example}[Contrazione di un grafo diretto]
    Si consideri il seguente grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [right of=3] {4};
            \node[main node] (6) [right of=1] {6};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (7) [right of=5] {7};
            \node[main node] (8) [below right of=7] {8};
            \node[main node] (9) [above right of=7] {9};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (3)
                (1) edge (6)
                (2) edge (1)
                (3) edge (2)
                (3) edge (4)
                (5) edge (4)
                (4) edge (6)
                (6) edge (5)
                (5) edge (7)
                (7) edge (9)
                (8) edge (7)
                (9) edge (8)
                ;
        \end{tikzpicture}
    \end{figure}
        
    contraendo la componente $H_1 = (\{1, 2, 3\}, \{(1, 3), (3, 2), (2, 1)\})$ in $v_{H_1}$, si ottiene:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.8,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (6) {6};
            \node[main node] (1) [below left of=6] {$v_{H_1}$};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [below right of=6] {5};
            \node[main node] (7) [right of=5] {7};
            \node[main node] (8) [below right of=7] {8};
            \node[main node] (9) [above right of=7] {9};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (6)
                (1) edge (4)
                (5) edge (4)
                (4) edge (6)
                (6) edge (5)
                (5) edge (7)
                (7) edge (9)
                (8) edge (7)
                (9) edge (8)
                ;
        \end{tikzpicture}
    \end{figure}

    contraendo la componente $H_2 = (\{4, 5, 6\}, \{(4, 6), (6, 5), (5, 4)\})$ in $v_{H_2}$, si ottiene:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.8,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {$v_{H_1}$};
            \node[main node] (5) [right of=1] {$v_{H_2}$};
            \node[main node] (7) [right of=5] {7};
            \node[main node] (8) [below right of=7] {8};
            \node[main node] (9) [above right of=7] {9};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (5)
                (5) edge (7)
                (7) edge (9)
                (8) edge (7)
                (9) edge (8)
                ;
        \end{tikzpicture}
    \end{figure}

    infine, contraendo la componente $H_3 = (\{7, 8, 9\}, \{(7, 9), (9, 8), (8, 7)\})$ in $v_{H_3}$, si ottiene il seguente grafo massimalmente contratto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.8,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {$v_{H_1}$};
            \node[main node] (5) [right of=1] {$v_{H_2}$};
            \node[main node] (7) [right of=5] {$v_{H_3}$};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (5)
                (5) edge (7)
                ;
        \end{tikzpicture}
        \caption{Il grafo iniziale massimalmente contratto.}
    \end{figure}
\end{example}

\begin{theorem}[Contrazioni fortemente connesse]
    \label{contrazioni fortemente connesse}
    Sia $G$ un grafo diretto fortemente connesso, e $H \subseteq G$ un suo sottografo fortemente connesso; allora, $\mathrm{contr}(G, H)$ è ancora fortemente connesso.
\end{theorem}

\begin{proof}
    Sia $v_H$ il vertice del grafo contratto $\mathrm{contr}(G, H)$, e $y \in V(G - H)$; poiché $G$ è fortemente connesso, devono necessariamente esistere due vertici $v', v'' \in V(H)$ tali che $y \rightarrow v'$ e $v'' \rightarrow y$; siano i vertici $v'$ e $v''$ per i quali tali cammini siano di minor lunghezza possibile. Allora, effettuando la contrazione di $H$, in $\mathrm{contr}(G, H)$ sarà necessario rimpiazzare gli archi che permettevano tali cammini, e dunque verranno inseriti due nuovi archi, uno entrante uno uscente, verso $v_H$. Allora, necessariamente $\mathrm{contr}(G, H)$ è ancora fortemente connesso.
\end{proof}

\begin{theorem}[Presenza di cicli]
    \label{presenza di cicli fort conn}
    Sia $G$ un grafo diretto fortemente connesso, non composto da un singolo vertice; allora, esso presenta almeno un ciclo.
\end{theorem}

\begin{proof}
    Per definizione $\forall u, v \in V(G) \quad u \rightarrow v$ e $v \rightarrow u$; allora, presi due vertici $u, v \in V(G)$, in $G$ deve necessariamente esistere un ciclo della forma $u \rightarrow v \rightarrow u$.
\end{proof}

\begin{algorithm}[H]
    \caption{
        Dato un grafo diretto $G$, rappresentato attraverso liste di adiacenza, con liste di archi sia entranti che uscenti per ogni vertice, l'algoritmo restiuisce le componenti di $G$.\\
        \textbf{Input}: $G$ grafo diretto, rappresentato attraverso liste di adiacenza, con liste di archi sia entranti che uscenti per ogni vertice.\\
        \textbf{Output}: le componenti di $G$.
    }

    \begin{algorithmic}[1]
        \Function{findCycle}{G}
            \State TODO deve funzionare in O(n + m)
        \EndFunction
        \\
        \Function{findComponents$_1$}{$G$}
            \State $C := \texttt{findCycle}(G)$
            \If{$C == \texttt{None}$}
                \State \textbf{return} $\verb|{|\{v\} : v \in V(G)\verb|}|$ \Comment{le componenti sono i singoli vertici}
            \Else
                \State $v_C, G = \mathrm{contr}(G, C)$ \Comment{$v_C$ è il vertice della contrazione}
                \State $\verb|{|H_1, \ldots, H_k\verb|}| = \texttt{findComponents}(G)$
                \State $\texttt{new\_components} := \verb|{|\verb|}|$ \Comment{conterrà le nuove componenti}
                \For{$i \in [1, k]$}
                    \If{$v_C \notin H_i$}
                        \State $\texttt{new\_components.add(}H_i\texttt{)}$
                    \Else
                    \State $\texttt{new\_components.add(}(H_i - \{v_C\}) \cup V(C)\texttt{)}$
                    \EndIf
                \EndFor
            \EndIf
            \State \textbf{return} \texttt{new\_components}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{remark}[Correttezza dell'algoritmo]
    Sia $G$ un grafo diretto, e $H \subseteq G$ una sua componente; allora, se $H$ non è composto da un singolo vertice, poiché è fortemente connesso per definizione, per il \cref{presenza di cicli fort conn}, in $H$ è presente un ciclo $C$; allora, contraendo tale ciclo, si otterrà un sottografo $\mathrm{contr}(H, C)$, ancora fortemente connesso, per il \cref{contrazioni fortemente connesse}. Allora, questo garantisce di poter trovare tutte le componenti di un grafo, contraendone ricorsivamente i cicli.

    TODO parla della funzione che trova i cicli in O(n + m)

    L'algoritmo inizia cercando un ciclo $C$ all'interno del grafo $G$; se non ne viene trovato alcuno, viene raggiunto il caso base della ricorsione, e l'algoritmo restituisce un insieme di insiemi dei singoli vertici di $G$; si noti che tale caso si presenta esclusivamente quando il grafo è massimalmente contratto.

    Differentemente, se è presente un ciclo $C$ all'interno del grafo, l'algoritmo procede contraendo $C$ in $v_C$, e rimpiazzando $G$, alla riga $10$; successivamente, viene effettuata una chiamata ricorsiva sul grafo contratto, al termine della quale viene restituito l'insieme di componenti di $G$ corrente.

    Dopo aver contratto ricorsivamente ogni possibile ciclo, l'algoritmo istanzia un loop \texttt{for} alla riga $13$, all'interno del quale viene trovata la componente $H_i$ in cui $v_C$ faceva parte: le componenti che non contengono $v_C$ vengono inserite all'interno dell'insieme \texttt{new\_components}, senza subire modifiche; al contrario, dall'unica componente $H_i$ che contiene $v_C$, viene rimosso $v_C$ stesso, e ad essa verrà aggiunto tutto il ciclo $C$ che era stato contratto, ripristinando dunque il grafo di partenza di ricorsione in ricorsione.
\end{remark}

\begin{remark}[Costo dell'algoritmo]
    TODO O(n(n + m))
\end{remark}

\begin{definition}[C-radici]
    Sia $G$ un grafo diretto, sia $\hat v \in V(G)$ un suo vertice, e sia $A_{\hat v}$ l'arborescenza di $\hat v$ in $G$; $v \in A_{\hat v}$ è detto \textit{c-radice} di $\mathrm{comp}(v)$ in $A_{\hat v}$, se e solo se è il primo vertice visitato in $\mathrm{comp}(v)$.
\end{definition}

\begin{example}[C-radici]
    Si consideri il seguente $G$ grafo diretto:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [below right of=4] {5};
            \node[main node] (7) [above right of=4] {7};
            \node[main node] (6) [below right of=7] {6};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (3)
                (1) edge (4)
                (2) edge (1)
                (3) edge (2)
                (3) edge (4)
                (4) edge (7)
                (5) edge (4)
                (5) edge (6)
                (7) edge (5)
                (7) edge (6)
                ;
        \end{tikzpicture}
        \caption{Un grafo diretto.}
    \end{figure}

    esso presenta $3$ componenti: $$H_1 = (\{1, 2, 3\}, \{(1, 3), (3, 2), (2, 1)\})$$ $$H_2 = (\{4, 5, 7\}, \{(4, 7), (7, 5), (5, 4)\})$$ $$H_3=(\{6\}, \varnothing)$$

    sia $\hat v = 2$, dunque la sua arborescenza $A_{\hat v}$ è la seguente:

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={scale=0.6,circle,draw,font=\sffamily\normalsize}]
            \node[main node] (1) {1};
            \node[main node] (2) [below left of=1] {2};
            \node[main node] (3) [below right of=2] {3};
            \node[main node] (4) [below right of=1] {4};
            \node[main node] (5) [below right of=4] {5};
            \node[main node] (7) [above right of=4] {7};
            \node[main node] (6) [below right of=7] {6};

            \path[every node/.style={font=\sffamily\small}]
                (1) edge (3)
                (1) edge (4)
                (2) edge (1)
                (4) edge (7)
                (5) edge (6)
                (7) edge (5)
                ;
        \end{tikzpicture}
        \caption{Arborescenza di $2$.}
    \end{figure}

    allora, in $H_1$ il primo vertice visitato da $A_{\hat v}$ è $2$, in $H_2$ è $4$, e in $H_3$ è $6$; allora le c-radici di $A_{\hat v}$ sono $\{2, 4, 6\}$.
\end{example}

\begin{theorem}[C-radici]
    Sia $G$ un grafo diretto, sia $\hat v \in V(G)$ un suo vertice, e sia $A_{\hat v}$ l'arborescenza di $\hat v$ in $G$; sia $u$ la c-radice di $\mathrm{comp}(u)$ in $A_{\hat v}$; allora si verificano le seguenti proposizioni:

    \begin{enumerate}[i)]
        \item sia $A_u \subseteq A_{\hat v}$ è l'arborescenza radicata in $u$; allora $$V(\mathrm{comp}(u)) \subseteq V(A_u)$$
        \item siano $u_1, \ldots, u_k$ le c-radici di $\mathrm{comp}(u_1), \ldots, \mathrm{comp}(u_k)$ in $A_u \subseteq A_{\hat v}$; allora $$V(\mathrm{comp}(u)) \cup \displaystyle \bigcup_{i = 1}^k {V(\mathrm{comp}(u_i))} = V(A_u)$$
    \end{enumerate}
\end{theorem}

\begin{proof}
    \hspace{0.7cm}
    \begin{enumerate}[\itshape i)]
        \item Per definizione, $\mathrm{comp}(u)$ è fortemente connesso, e dunque per ogni $v \in \mathrm{comp}(u)$ esistono due cammini $u \rightarrow v$ e $v \rightarrow u$; allora, partendo da $u$, necessariamente $v \in V(A_{\hat v})$, poiché la visita in DFS di $\hat v$ deve aver raggiunto $v$. Infine, $v$ non potrebbe essere stato visitato prima di $u$, poiché $u$ è stato scelto come c-radice di $\mathrm{comp}(u)$; allora necessariamente $v \in V(A_u)$, e dunque $V(\mathrm{comp}(u)) \subseteq V(A_u)$.
        \item Si noti che $u_1, \ldots, u_k \in V(A_u)$, e dunque per definizione $$\forall i \in [1, k] \quad V(A_{u_i}) \subseteq V(A_u)$$
            Inoltre, per la proposizione precedente, si ha che $$\forall i \in [1, k] \quad V(\mathrm{comp}(u_i)) \subseteq V(A_{u_i})$$ e anche che $$V(\mathrm{comp}(u)) \subseteq V(A_u)$$
            Allora, necessariamente $$V(\mathrm{comp}(u)) \cup \displaystyle \bigcup_{i = 1}^k {V(\mathrm{comp}(u_i))} \subseteq V(A_u)$$
            Sia $w \in V(A_u)$, e dunque esiste un cammino $u \rightarrow w$:
            
            \begin{itemize}
                \item se esiste un cammino $w \rightarrow u$, poiché $\mathrm{comp}(u)$ è massimalmente fortemente connesso per definizione, necessariamente $w \in \mathrm{comp}(u)$; allora $V(A_u) \subseteq \mathrm{comp}(u)$, e dunque segue la tesi;
                \item allora, si supponga non esista un tale cammino $w \rightarrow u$, e dunque $\mathrm{comp}(u) \neq \mathrm{comp}(w)$, per il \cref{disjoint comps}; allora, sia $z \in V(\mathrm{comp}(w))$ la c-radice di $\mathrm{comp}(w) = \mathrm{comp}(z)$; si noti che $z \in \mathrm{comp}(w)$, implica che è presente in $G$ un cammino $w \rightarrow z$, e dunque si ha un cammino $u \rightarrow w \rightarrow z$ in $G$; allora, la visita in DFS di $\hat v$ deve aver necessariamente raggiunto $z$, e dunque $z \in V(A_{\hat v})$;
                \item per assurdo, sia $z \notin V(A_u)$; poiché in $G$ si ha un cammino $u \rightarrow w \rightarrow z$ per osservazione precedente, allora segue che $t(z) < t(u)$, e dunque $z$ deve essere stato visitato prima di $u$, altrimenti sarebbe stato raggiunto a partire da $u$; allora:
                \begin{itemize}
                    \item sia $\mathrm{Int}(z) \cap \mathrm{Int}(u) = \varnothing$: si noti che $z \in \mathrm{comp}(w)$ è c-radice di $\mathrm{comp}(w)$, e dunque si ha il cammino $z \rightarrow w$; allora, poiché $\mathrm{Int}(w) \subseteq \mathrm{Int}(u)$, la visita in DFS avrebbe sbagliato a non controllare $w$ prima di rimuovere $z$ dallo stack $\lightning$
                    \item sia $\mathrm{Int}(z) \supset \mathrm{Int}(u) \supseteq \mathrm{Int}(w)$: allora si avrebbe che $A_u \subset A_z$, e dunque esiste un cammino $z \rightarrow u$, ma per il cammino $u \rightarrow w \rightarrow z$, allora si avrebbe $\mathrm{comp}(z) = \mathrm{comp}(u)$, contraddicendo l'ipotesi per cui $\mathrm{comp}(u) \neq \mathrm{comp}(w) = \mathrm{comp}(z) \ \lightning$
                \end{itemize}
            \item allora necessariamente $z \in V(A_u)$, e poiché è stato scelto come c-radice di una delle componenti di $G$ in $A_u$, allora deve verificarsi che $z \in \{u_1, \ldots, u_k\}$;
            \item dunque $\exists i \in [1, k] \mid z= u_i$, e poiché $\forall i \in [1, k] \quad u_i \in V(\mathrm{comp}(u_i))$, allora $$z \in V(A_u) \implies \exists i \in [1, k] \mid z = u_i \in V(\mathrm{comp}(u_i))$$ dunque $V(A_u) \subseteq V(\mathrm{comp}(u_i))$ per qualche $i \in [1, k]$, e quindi segue la tesi.
            \end{itemize}
    \end{enumerate}
\end{proof}

\end{document}
